{"pages":[],"posts":[{"title":"Chapter 38-41 线程常用操作方法","text":"了解线程的常用操作方法：线程命名与取得、线程的休眠、线程优先级 以及线程的同步与死锁问题。 多线程实现java是一门为数不多的多线程支持的语言。 在同一时间段上，会有多进程轮流去抢占资源，你在某一个时间点上，只有一个进程运行。线程是比进程更快的处理单元，而且所占的资源也小。线程的存在离不开进程，进程消失了线程一定会消失，但是线程消失了进程不一定会消失。 Java 三种线程的实现方式,主要用前两种。 继承Thread类 实现Runnable接口(Callable接口) 1. Thread类Thread是一个支持多线程的类，只要有一个子类它就可以实现多线程的支持。在多线程的每个主体类之中都必须覆写 Thread 类中提供的 run() 方法。public void run()这个方法没有返回值，那么也表示线程一旦开始就要一直执行，不能够返回内容。多线程启动的唯一方法是 Thread 类中的 start() 方法:public void start() ( 调用此方法执行的方法体是 run() 方法中的内容 ) 一个线程只能启动一次，重复启动会抛出 IllegalThreadStateException 异常。 使用 Thread 类中的 start() 方法不仅仅要启动多线程的执行代码，而且还要根据操作系统进行资源分配。 2. Runnable接口实现继承 Thread 类会有继承局限，所以使用 Runnable 接口。Runnable 中有public void run(); 方法，（接口中的方法默认权限为 public ，写不写都是 public ） 使用： 覆写接口里面的 run() 方法 调用 Thread.start() 方法才能启动线程。Thread 中有如下构造方法public Thread(Runnble target),因此 Thread 也可以接受 Runnable 的任意子类。 Thread 类和 Runnable 两种方式的实现区别: Runnbale 避免了单继承局限。 Thread 类是 Runnable 接口的子类。Thread 类定义class Thread extends Object implements Runnable,查看描述图，非常类似于客户代理模式，但不同的是：客户代理模式中，客户端使用的方法应该是接口里提供的，而 Runnable 并没有实现 start() 方法! Runnable 接口比 Thread 类更能描述出数据共享这一概念（Thread 也可以实现）。数据共享指多个线程访问统一资源的操作。 【\b示例】 创建多个线程对象MyThread 是 Thread 的子类，那么具有 start() 方法，再去 new Thread()并不好。MyThread implements Runnable 的话：new Thread()完全正确。 123456//Mythread extends Thread的话：MyThread是Thread的子类，那么具有start()方法，再去new Thread()并不好//MyThread implements Runnable的话：new Thread()完全正确。Mythread mt = new MyThread();new Thread(mt).start();new Thread(mt).start();new Thread(mt).start(); 这三个线程对象同时占用了MyThread类引用， 那么这三个对象访问同一块数据资源。 【示例】第三种实现方式： 123456789101112131415161718192021222324252627282930package com.company;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;class MyThread implements Callable&lt;String&gt;{ private int num = 10; @Override public String call() { for(int i = 0 ;i &lt;100 ; i++){ if(num &gt; 0) System.out.println(\"卖票，ticket=\" + this.num--); } return \"票已卖光\"; }}public class TestFunc { public static void main(String[] args) throws ExecutionException, InterruptedException { MyThread mt1 = new MyThread(); MyThread mt2 = new MyThread(); FutureTask&lt;String&gt; task1 = new FutureTask&lt;String&gt;(mt1);//为了取得call()的返回结果 FutureTask&lt;String&gt; task2 = new FutureTask&lt;String&gt;(mt2); //FutureTask是Runnable的子类，所以可以使用Thread类的构造来接收task对象 new Thread(task1).start(); //启动多线程 new Thread(task2).start(); //多线程执行完毕之后可以取得内容，依靠FutureTask的父接口Future的get()方法完成 System.out.println(task1.get()); System.out.println(task2.get()); }} 线程常用操作方法1. 线程的命名与取得线程一般会在其启动之前进行定义，不建议在线程启动后进行更改名称，或者对不同的线程设置重名的操作。 线程名称操作，使用Thread类: 构造方法:public Thread(Runnable target,String name) 设置名字:public final void setName(String name) 取得名字:public final String getName() 这些方法是Thread类的，而我们的线程类是Runnable的子类。如果想要取得线程的名字，那么我们只能取得当前执行本方法的线程的名字。类中提供一个方法: 取得当前线程对象:public static Thread currentThread()如果在实例化Thread对象时没有为其设置名字，那么会自动的进行编号命名，保证线程名称不重复。123456789101112131415161718192021package com.company;import java.util.concurrent.ExecutionException;class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()); }}public class TestFunc { public static void main(String[] args) throws ExecutionException, InterruptedException { MyThread mt1 = new MyThread(); new Thread(mt1).start(); new Thread(mt1,&quot;A&quot;).start(); new Thread(mt1).start(); new Thread(mt1,&quot;B&quot;).start(); new Thread(mt1).start(); }} 123MyThread mt = new MyThread();new Thread(mt,&quot;自己的线程&quot;); //output：&quot;自己的线程&quot;mt.run();//output：main 结论：原来主方法是一个线程(main线程)，所有在主方法上创建的线程都可以将其表示为子线程。每当使用Java命令去解释一个程序类时，对操作系统而言，都相当于启动了一个新进程，而main相当于这个进程的一个子线程。 ** 提问：**每个JVM启动时都至少要启动几个线程？ mian线程：程序的主要执行，以及启动子线程。 gc线程：负责垃圾收集2. 线程的休眠线程的休眠就是让线程的执行速度变得稍微慢一点。休眠方法：12public sratic void sleep(long millis) throws InterruptedException// InterruptedException 代表中断异常，时间是以毫秒 ms 为单位的 3. 线程优先级越高的优先级越有可能先执行。Thread 类中提供了两个方法进行优先级操作： 设置优先级: public final void setPriority(int newPriority); 取得优先级: public int getPriority();设置和取得优先级都是使用了 int 数据类型，对此内容有三种取值： 最高优先级: public static final int MAX_PRIORITY, 10 中等优先级: public static final int NORM_PRIORITY, 5 最低优先级: public static final int MIN_PRIORITY, 1 主线程是中等优先级 5，Thread.currentThread().getPriority() 线程的同步与死锁（了解）同步问题的引出：同步指的是多个线程访问同一资源所需要考虑到的问题。判断与修改数据分开就会造成不同步问题，（判断是否有剩余票 - 休眠 - 修改剩余票数）示例代码： 1234567891011121314151617181920212223242526272829package com.company;import java.util.concurrent.ExecutionException;class MyThread implements Runnable{ private int ticket = 5; @Override public void run() { for(int i =0 ;i&lt; 100 ;i++){ if(this.ticket &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\" 卖票，ticket = \"+ this.ticket--); } } }}public class TestFunc { public static void main(String[] args) throws ExecutionException, InterruptedException { MyThread mt = new MyThread(); new Thread(mt,\"A\").start(); new Thread(mt,\"B\").start(); new Thread(mt,\"C\").start(); new Thread(mt,\"D\").start(); }} 同步操作可以将（判断是否有剩余票 - 休眠 - 修改剩余票数）封装起来。 Java 中要实现线程的同步可以使用 synchronized 关键字。使用方法： 同步代码块（Java有四种代码块：普通代码块、构造块、静态块、同步块），必须锁定一个对象。 同步方法 异步操作的执行速度要高于同步操作，但是同步操作时数据安全性较高，属于操作安全的线程操作。 死锁线程同步过多就会造成死锁。 面试题： 请解释多个线程访问同一资源时需要考虑哪些情况？有可能带来哪些问题？ 多个线程访问统一资源时一定要处理好同步，可以使用同步代码块或者同步方法； 同步代码块：synchronized(锁定对象){代码} 同步方法：public synchronized 返回值 方法名称(){代码} 但是过多的使用同步，有可能造成死锁。 综合实战：生产者和消费者生产者和消费者之的是两个不同的线程对象，操作统一资源的情况，具体的操作流程如下： 生产者负责产生数据，消费者负责取走数据 生产者每生产完一组数据之后，消费者就要取走一组数据 等待与唤醒机制 等待：public final void wait() throws InterruptedException; 唤醒第一个等待线程：public final void notify(); 唤醒全部等待线程，优先级高的先执行：public final void notifyAll()以下代码注意的三点： 将 get() 和 set() 设置为同步方法可以解决数据错位问题 增加等待唤醒机制 super.wait()、super.notyfy() 可以保证生产一个，取出一个。 设置标记flag时要初始化，否则默认为false，会取出null-null123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.company;class Info{ private String title; private String content; // flag = true 表示可以生产，但是不可以取走 /// flag = false 表示可以取走，但是不可以生产 private boolean flag = true; //如果不指定flag，默认为false，会取出null-null public Info() {} public synchronized void set(String title,String content){ if(this.flag == false){ try { super.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } this.title = title; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } this.content = content; this.flag = false; //修改生产标记 super.notify(); //唤醒其他等待进程 } public synchronized void get(){ if(flag == true){ try { super.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(this.title + \" - \" + this.content); this.flag = true; //修改生产标记 super.notify(); //唤醒其他等待线程 }}class Productor implements Runnable{ private Info info; public Productor(Info info) { this.info = info; } @Override public void run() { for(int i = 0 ;i &lt; 100; i++){ if(i % 2 == 0){ this.info.set(\"苏一一\",\"大帅哥\"); }else{ this.info.set(\"姣姣\",\"小可爱\"); } } }}class Consumer implements Runnable{ private Info info; public Consumer(Info info) { this.info = info; } @Override public void run() { for(int i = 0; i &lt; 100 ; i++){ try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } this.info.get(); } }}public class TestProCon { public static void main(String args[]){ Info info = new Info(); new Thread(new Productor(info)).start(); new Thread(new Consumer(info)).start(); }} 面试题： 请解释 sleep() 与 wait() 方法的区别 sleep() 是 Thread 类定义的方法，而 wait() 是 Object 类定义的方法 sleep() 可以设置休眠时间，时间一到自动唤醒，而 wait() 需要等待 notify() 进行唤醒","link":"/2018/10/24/Java_38-41_线程常用方法与实战/"},{"title":"docker搭建ELK日志收集系统","text":"docker-compose搭建日志收集系统 Docker-compose介绍Docker-Compose 是 Docker 的一种编排服务，是一个用于在 Docker 上定义并运行复杂应用的工具，可以让用户在集群中部署分布式应用。 通过 Docker-Compose 用户可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。 与Dockerfile的区别：Dockerfile 可以让用户管理一个单独的应用容器；而 Compose 则允许用户在一个模板（YAML 格式）中定义一组相关联的应用容器（被称为一个 project，即项目），例如一个 Web 服务容器再加上后端的数据库服务容器等。 即Dockerfile创建应用，docker-compose.yml创建项目。 ELK介绍ELK = Elasticsearch + Logstash + Kibana Elasticsearch：用于存储收集到的日志信息 Logstash：用于收集日志，SpringBoot应用整合Logstash以后会把日志发送给Logstash，Logstash将日志转发到Elasticsearch Kibana：通过浏览器端可视化界面查看Elasticsearch中的日志信息 step1 下载镜像123docker pull elasticsearch:6.7.0docker pull logstash:6.7.0docker pull kibana:6.7.0 step2 搭建1. 创建存放logstash配置的目录并将配置文件放进去logstash-springboot.conf文件 Logstash 是 Elasticsearch 的最佳数据管道。Logstash 是插件式管理模式，在输入、过滤、输出以及编码过程中都可以使用插件进行定制。input 负责从数据源采集数据（必选），filter 将数据修改为你指定的格式或内容（可选），output 将数据传输到目的地（必选）。参考 该文件指定logstash的输入和输出，从4560端口输出到elasticsearch。 1234567891011121314input { tcp { mode =&gt; &quot;server&quot; host =&gt; &quot;0.0.0.0&quot; port =&gt; 4560 codec =&gt; json_lines }}output { elasticsearch { hosts =&gt; &quot;es:9200&quot; index =&gt; &quot;springboot-logstash-%{+YYYY.MM.dd}&quot; }} 创建配置文件存放目录并上传配置文件到该目录 mkdir /mydata/logstash 2. docker-compose.yml脚本启动ELK服务docker-compose.yml文件 version: '3'表示参考和指南这些主题描述了Compose文件格式的第3版 compose文件模板的编写参考 注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。container_name规定容器的名字，environment设定容器的环境，volumes设置挂载文件目录等，ports设置暴露的端口等。 1234567891011121314151617181920212223242526272829303132333435services: elasticsearch: image: elasticsearch:6.7.0 container_name: elasticsearch environment: - &quot;cluster.name=elasticsearch&quot; #设置集群名称为elasticsearch - &quot;discovery.type=single-node&quot; #以单一节点模式启动 - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; #设置使用jvm内存大小 volumes: - /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins #插件文件挂载 - /mydata/elasticsearch/data:/usr/share/elasticsearch/data #数据文件挂载 ports: - 9200:9200 kibana: image: kibana:6.7.0 container_name: kibana links: - elasticsearch:es #可以用es这个域名访问elasticsearch服务 depends_on: - elasticsearch #kibana在elasticsearch启动之后再启动 environment: - &quot;elasticsearch.hosts=http://es:9200&quot; #设置访问elasticsearch的地址 ports: - 5601:5601 logstash: image: logstash:6.7.0 container_name: logstash volumes: - /mydata/logstash/logstash-springboot.conf:/usr/share/logstash/pipeline/logstash.conf #挂载logstash的配置文件 depends_on: - elasticsearch #logstash在elasticsearch启动之后再启动 links: - elasticsearch:es #可以用es这个域名访问elasticsearch服务 ports: - 4560:4560 在docker-compose.yaml所在目录下面执行docker-compose命令 1docker-compose up -d -d表示后台运行，启动需要一些时间，请耐心等待 若容器没有被创建，上述命令创建容器；如果容器已经被创建，上述命令会重新启动容器。 3. 在logstash中安装json_lines插件12345678910# 进入logstash容器docker exec -it logstash /bin/bash# 进入bin目录cd /bin/# 安装插件logstash-plugin install logstash-codec-json_lines# 退出容器exit# 重启logstash服务docker restart logstash 4. 开启防火墙并在kibana中查看如果项目部署在远程服务器上，注意是否要开启防火墙 1systemctl stop firewalld 访问地址：http://localhost:5601 若在远程服务器上部署，将localhost换成远程服务器的ip step3 SpringBoot中集成1. 添加依赖在 pom.xml中添加logstash-logback-encoder依赖 123456&lt;!--集成logstash--&gt;&lt;dependency&gt; &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt; &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt; &lt;version&gt;5.3&lt;/version&gt;&lt;/dependency&gt; 2. 添加配置文件添加配置文件logback-spring.xml让logback的日志输出到logstash 注意：appender节点下的destination改成logstash服务地址，这里是本地：0.0.0.0:4560 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration&gt;&lt;configuration&gt; &lt;include resource=\"org/springframework/boot/logging/logback/defaults.xml\"/&gt; &lt;include resource=\"org/springframework/boot/logging/logback/console-appender.xml\"/&gt; &lt;!--应用名称--&gt; &lt;property name=\"APP_NAME\" value=\"mall-admin\"/&gt; &lt;!--日志文件保存路径--&gt; &lt;property name=\"LOG_FILE_PATH\" value=\"${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}}/logs}\"/&gt; &lt;contextName&gt;${APP_NAME}&lt;/contextName&gt; &lt;!--每天记录日志到文件appender--&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;${LOG_FILE_PATH}/${APP_NAME}-%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;${FILE_LOG_PATTERN}&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到logstash的appender--&gt; &lt;appender name=\"LOGSTASH\" class=\"net.logstash.logback.appender.LogstashTcpSocketAppender\"&gt; &lt;!--可以访问的logstash日志收集端口--&gt; &lt;destination&gt;0.0.0.0:4560&lt;/destination&gt; &lt;encoder charset=\"UTF-8\" class=\"net.logstash.logback.encoder.LogstashEncoder\"/&gt; &lt;/appender&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\"/&gt; &lt;appender-ref ref=\"FILE\"/&gt; &lt;appender-ref ref=\"LOGSTASH\"/&gt; &lt;/root&gt;&lt;/configuration&gt; 3. 运行spring项目在kibana中查看日志在Management/Kibana中选择Index Patterns，创建一个index pattern， 匹配的模式为 springboot-logstash-*，next-step选择@timestamp作为过滤时间的field。 在左侧面板Discover中选择刚创建的模式查看日志信息 总结搭建了ELK日志收集系统之后，我们如果要查看SpringBoot应用的日志信息，就不需要查看日志文件了，直接在Kibana中查看即可。","link":"/2019/10/23/ELK日志收集系统/"},{"title":"Chapter 42 Java 基础类库","text":"学习 StringBuffer 类、Runtime 类、System 类\b与对象克隆的基本概念和举例。 Chapter 42 : Java 基础类库1. StringBuffer 类【回顾】String 类的特点： String 类对象有两种实例化方式 |- 直接赋值：\b只开辟一块堆内存空间，可以自动入池 |- 构造方法：开辟两块堆内存空间，不会自动入池，使用 intern() 方法手动入池 任何一个字符串都是 String 类的匿名对象 字符串一旦声明不能改变，改变的只是\b String 类对象的引用。 由于 String 类对象不可改变，Java 提供 StringBuffer 类（里面的内容可以改变）。String 类使用 “+” 进行字符串连接，而 StringBuffer 使用 append() 增加数据 方法: public StringBuffer append(数据类型 变量) 注意： String 类可以直接赋值实例化，StringBuffer 不可以。 12345678910111213public class TestDemo { public static void main(String[] agrs){ // String 类可以直接赋值实例化，但是 StringBuffer 不可以 StringBuffer buf = new StringBuffer(); buf.append(\"Hello \").append(\"world\").append(\"!\"); change(buf); //引用传递 System.out.println(buf); } public static void change(StringBuffer temp){ temp.append(\"\\n\").append(\"Hello Java!\"); }} String 类和 StringBuffer 类都是 CharSequence 的子类，因此在开发中遇到 CharSequence 接口，\b那么传递字符串即可。 123456public class TestDemo { public static void main(String[] agrs){ CharSequence seq = \"hello\"; //向上转型 System.out.println(seq); // String 类覆写的 toString(） }} 虽然 String 和 StringBuffer 有着共同的接口，但是两个类对象之间不能直接转换。 将 String 对象转换为 StringBuffer 对象 利用 StringBuffer 的构造方法 ( public StringBuffer(String str) ); 利用 append() 方法：public StringBuffer append(String str)12345678910public class TestDemo { public static void main(String[] agrs){ StringBuffer buf1 = new StringBuffer(\"Hello\"); //第一种方式，利用构造方法 ：将 String 转换为StringBuffer StringBuffer buf2 = new StringBuffer();buf2.append(\"World\"); //第二种方式，利用 append() 方法：将 String 转换为StringBuffer System.out.println(buf2); }} 将 StringBuffer 类转换为 String类 使用 toString()方法。（任何类都可以利用该方法转换为String类） 1234567public class TestDemo { public static void main(String[] agrs){ StringBuffer buf = new StringBuffer(\"Hello\"); String str = buf.toString(); System.out.println(str); }} 也可以利用 String 类的构造方法：public String(StringBuffer buffer) String 类中和 StringBuffer 类比较的方法：public boolean contentEquals(StringBuffer buffer) 123456public class TestDemo { public static void main(String[] agrs){ StringBuffer buf = new StringBuffer(\"Hello\"); System.out.println(\"Hello\".contentEquals(buf)); }} StringBuffer 中提供了很多方法，可以与String类中的方法互补 字符串反转： public StringBuffer reverse() 在指定的索引位置增加数据：public StringBuffer insert(int offset,数据类型 变量) 删除部分数据: public StringBuffer delete(int start,int end) 注意： 在 JDK\u001c1.5 之后提供了 StringBuilder 类，该类与 StringBuffer 的定义非常相似，几乎连方法也一样。问题 解释 String、StringBuffer、StringBuilder 的区别 String 的内容一旦声明则不可改变，而 StringBuffer 和 StringBuilder 声明的内容可以改变 StringBuffer 中提供的方法都是同步方法（使用关键字 synchronized），属于安全的线程操作； 而 StringBuilder 中提供的方法是异步方法，属于非线程安全的操作。异步性能更好，同步数据安全性更高。 日后开发中：对于字符串的应用 95% 使用String 类，只有在需要频繁修改时才会考虑到 StringBuffer 或者 StringBuilder 类操作。（StringBuffer 出现时间长，使用的频率也比 StringBuilder 高，并且更安全） 2. Runtime 类在每一个JVM进程中都存在一个 Runtime 类，这个类的主要功能是取得一些与运行时有关的环境属性或者创建新进程操作。在 Runtime 定义时，构造方法已经被私有化，单利设计模式的应用，保证整个进程中只有唯一一个 Runtime 类。所以 Runtime 中有 static 方法可以取得 Runtime 的实例化对象。public static Runtime getRuntime()Runtime 是直接与本地运行有关的相关属性集合，因为 Runtime 类中有如下方法： 返回所有可用内存空间：public long totalMemory() 返回最大可用内存空间：public long maxMemory() 返回空余内存空间：public long freeMemory()产生垃圾后，空余内存空间会减小。Runtime 调用 public void gc()方法可以释放垃圾空间。 问题：什么叫GC，如何处理。 GC (Garbage Collector)垃圾收集器，指的是释放无用的内存空间。 GC 会由系统不定期自动回收，或者调用 Runtime 中的 gc() 方法手动回收。 Runtime 还有一个功能：可以调用本机的可执行程序，创建进程。 3. System类 System 类使用 System.arraycopy() 实现数组拷贝的功能:public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 取得当前的系统时间：public static long currentTimeMillis 举例： 统计某个操作花费的时间： 1234567891011public class TestDemo { public static void main(String[] agrs){ long start = System.currentTimeMillis(); //取得开始时间 String str = \"\"; for(int i = 0; i &lt; 1000 ; i++){ str += i; } long end = System.currentTimeMillis(); //取得结束时间 System.out.println(\"本次操作花费时间：\" + (end - start)); //时间单位为毫秒 ms }} System 的 gc() 方法: public void gc()。定义中表明了，该方法并不是新方法，而是调用了 Runtime 中的 gc()。（Runtime.getRuntime().gc() 方法） 对象产生一定会调用构造方法，但是对象要被回收了需要进行收尾，那么需要覆写 Object 类中的 finalize()。定义：protected void finalize() throws Throwableprotected 可以被同一包中的类、不同包中的子类访问。Throwable 是 Exception 和 Error 的父类，说明两种情况都可能出现。 |- 程序回收时就算抛出了异常也不会影响整个程序的正常执行。 123456789101112131415161718class Member{ public Member(){ System.out.println(\"小鸡咕咕咕\"); } @Override protected void finalize() throws Throwable { System.out.println(\"鸡升天了！\"); throw new Exception(\"我会回来的！\"); }}public class TestDemo { public static void main(String[] agrs){ Member mem = new Member(); // 出生时的辅助操作 mem = null; // 产生垃圾 System.gc(); // 手工处理垃圾收集 }} 构造方法是留给对象初始化时使用的，而 finalize() 方法是留给对象回收前使用的。类比 C++ 中的析构函数。 问题：请解释 final、finally、finalize 的区别 final：关键字，定义不能被继承的类、不能被覆写的方法、常量； finally：关键字，异常处理的统一出口； finalize：方法，Object 类提供\b的方法（protected void finalize() throws Throwable），指的是对象回收前的收尾方法，即使出现了异常也不会导致程序中断执行。 4. 对象克隆对象的克隆指的是对象的复制，在 Object 类中提供了一个专门的克隆方法 对象克隆：protect Object clone() throws CloneNotSupportedException此方法上抛出一个 “CloneNotSupportedException” 异常，如果要使用对象克隆的类没有实现 Cloneable 接口就会抛出该异常，但是 Cloneable 接口中看不见方法，那么该接口为一个 标识 接口，表示一种操作能力。 范例* 实现克隆方法123456789101112131415161718192021222324252627282930313233class Book implements Cloneable{ private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } public void setTitle(String title) { this.title = title; } @Override public String toString() { return \"书名：\" + this.title + \"、价格是：\" + this.price; } // 由于此类需要克隆对象操作，因此进行方法的覆写 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); // 调用父类的克隆方法 }}public class TestDemo { public static void main(String[] agrs) throws CloneNotSupportedException { Book bookA = new Book(\"Java开发\",79.3); Book bookB = (Book) bookA.clone(); bookB.setTitle(\"JSP开发\"); //证明不是clone不是对象的引用 System.out.println(bookA); System.out.println(bookB); }} 如果 Book 类中不覆写 clone() 方法，那么 bookA 没有克隆的能力。本节主要了解没有方法的接口，标识接口的使用，表示一种能力。","link":"/2018/10/24/Java_42_Java基础类库/"},{"title":"Hexo 学习笔记","text":"利用 Hexo 做个人站点 Hexo学习笔记下载安装Node.js,使用教程参考(http://www.runoob.com/nodejs/nodejs-tutorial.html)Hexo Hexo介绍利用Hexo做站点的原理：利用Hexo将*.md文件转为.html文件上传到\bGithub的仓库中。 基本原理图 安装全局安装 Hexo 软件，这里是安装 2.8.3 版本的 Hexo 而不是最新的，因为最新的有缺陷如果安装错了，可以使用卸载命令npm uninstall hexo -g安装指定版本命令：npm install -g hexo@2.8.3安装完成后，使用如下命令检查是否安装正确，及版本号是不是正常hexo version 准备md文件新建一个 Markdown 文件 git.md，把下面的内容复制粘贴进去： 开头有一个需要描述这个笔记的元信息，使用的是 YAML 格式，可以学习一下，推荐一个教程 阮一峰 YAML 语言教程 title 表示笔记名，date 是编写日期，tags 是标签，categories 是分组，这里用了多级分组的方式，将这片笔记分到了 ☎ 经验累积/其他 分组下； 注意:* title: 后面要加空格，否则不能正常显示 元信息必须使用 --- 包裹起来，而且必须是第一行（其实不用，只是比较好看而已）； &lt;!--more--&gt; 是用来分割摘要和正文的，也就是在笔记列表中只显示摘要，而在浏览全文时才全部展开； 其他的元信息标记可以在 Hexo 的官网查看。 12345678910111213141516--- title: git 学习笔记date: 2018/3/20 tags: git categories: - ☎ 经验累积 - 其他 --- 这里是笔记摘要 blablablabla.... &lt;!--more--&gt; # git 介绍 正文 blablabla.... 参考资料： - [廖雪峰的 git 教程] (https://www.liaoxuefeng.com/) - [菜鸟 Git 教程](http://www.runoob.com/git/git-tutorial.html) ## 分支管理 最简单的方法，就是直接把 `master` 指向 `dev` 的当前提交，就完成了合并。 下面是正文 blablabla.... Hexo本地站点 首先需要新建一个文件夹，例如在用户目录下新建mysite文件夹mkdir mysite 进入该目录cd mysite 使用 hexo init 初始化这个空目录，也就是将 Hexo 的工具拷贝一份到这里hexo init 使用命令 ls 可以查看当前文件夹下多了一些内容： _config.yml 站点配置文件，需要配置各种信息； themes 主题文件夹，里面放各种花样的主题； source Markdown 文件夹，里面放需要编译的材料； package.json 是 Hexo 的依赖清单； .gitnore git 程序的忽略配置（不重要）； scaffolds 模板文件夹，里面放模板（不重要）； 在 Hexo 可以用之前还需要给它安装依赖，使用 npm install 会根据 package.json 文件里列出的依赖全部安装，并安装在 node_modules 文件夹里。npm install 运行hexo s，出现 Hexo is running 的提示后，打开浏览器 http://localhost:4000/ 访问即可。hexo s，若出现 Cannot read property ‘config’ of null 问题，查看后面的Bug解决 自定义 Hexo 修改站点名称修改 hexo 的配置，让它能展现出我们自己站点的必要信息，这些必要信息在主目录的 _config.yml 文件。title: Hexo表示站点名，可以修改为title: XX的个人主页其他配置可以参考：hexo配置详解(nextT主题)。修改后关闭控制台，重新运行能够读取新配置。 主题主题是 Hexo 的一张皮，主要是给站点提供多样化的外观样式，你们可以在这面这个帖子找到一些有意思的主题来玩玩知乎 - 有哪些好看的 Hexo 主题下载主题文件夹后，放在主目录的 themes 文件夹，然后在 _config.yml 配置文件中修改 theme 一项的值为对应的文件夹名即可。比如默认的就是 themes/landscape 主题。 笔记现在我们将之前写的 git.md 放到 source/_post/ 目录下，并删除 hello-world.md，然后刷新 http://localhost:4000 的页面，应该能发现我们的笔记已经出现在站点里了。Hexo 的本地站点有缓存这种东西，所以如果删了 hello-world.md，页面还有的话，先关掉 Hexo，然后使用 hexo clean 清空缓存，再启动 Hexo。 部署 手动部署 使用 hexo g 命令将 source 文件夹下的材料生成一堆可以直接打开的 HTML 静态文件，这些静态文件就放在主目录的 public 文件夹下。双击里面的 index.html 就可以看到效果。这时，可以直接将 public 文件夹整个放到你的 github.io 那个仓库里，具体的做法是把 public 文件夹当做之前上传 Markdown 文件夹一样，用 git init 初始化，add 添加文件，commit 提交，push 推送即可。命令： 1234567891011121314hexo gcd public git initgit add 2018/git add categories/git add fancybox/git add js/git add archives/git add css/git add index.htmlgit add tags/git commit -m &quot;describe&quot;git remote add origin git@github.com:fujiao9614/fujiao9614.github.io.gitgit push -u origin master Hexo部署Hexo 将手动所需要的流程集合成一个命令 hexo d，具体如下： 配置目标的仓库 hexo d 一下即可 打开你的 github.io 即可查看配置需要打开 hexo 主目录的 _config.yml 配置文件，拉到最后，修改为如下： 1234deploy: type: github repository: git@github.com:fujiao9614/fujiao9614.github.io.git branch: master Bug解决出现 Cannot read property ‘config’ of null 问题， [error] HexoError: Process failed: _posts/hello-world.md TypeError: Cannot read property 'config' of null 原因：hexo 依赖的版本有旧依赖解决方法：是如下命令指定依赖版本： npm install hexo-renderer-ejs@0.1.0 hexo-renderer-marked@0.1.0 hexo-renderer-stylus@0.1.0 参考：这个世界会好吗 - Hexo降级到v2.8.3小记 { “hexo”: {“version”: “” } }","link":"/2018/11/05/Hexo/"},{"title":"日期操作类","text":"学习使用日期操作类 日期操作类1. Date 类Date 类属于简单 Java类的一部分。Java 中提供了 java.util.Date 的类，直接表示当前的日期时间 示例： 取得当前日期时间 12345678import java.util.Date;public class TestDemo { public static void main(String[] agrs){ Date date = new Date(); //输出格式：Fri Oct 19 00:04:29 CST 2018 System.out.println(date); }} long 可以描述日期时间数据，Data 类中可以看出，有以下几个重要方法： 无参构造：public Date() 有参构造：public Date(long date),接收 long 型数据。 【重点】转换为 long 型：public long getTime()，开发中经常用到，重点！ 示例： Date 类型和 \blong 类型的互相转换 1234567891011import java.util.Date;public class TestDemo { public static void main(String[] agrs) { long cur = System.currentTimeMillis(); // 取得当前时间以 long 型返回 Date date = new Date(cur); // 输出对象信息 Fri Oct 19 00:11:40 CST 2018 System.out.println(date); // 输出对象信息 1539879100377 System.out.println(date.getTime()); }} 2. 日期格式化：SimpleDateFormat（核心）java.text 是一个专门实现国际化程序的开发包，而 SimpleDateFormat 是一个专门处理格式化日期的工具类，即将 Date 型的对象转化为 String 形式。主要使用的是以下几个方法： 构造方法：public SimpleDateFormat(String pattern),需要传递转换格式 将 Date 转换为 String：public final String format(Date date); 将 String 转换为 Date：public Date parse(String source) throws ParseException。 对于转换格式，常见的转换单位有 年（yyyy），月（MM），日（dd），\b时（HH），分（mm），秒（ss），毫秒（SSS），注意大小写！示例： 日期格式化显示（将 Date 型数据变为 String 型数据、将 String 型数据\b变为 Date 型） 123456789101112131415161718192021import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class TestDemo { public static void main(String[] agrs) { Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\"); String str = sdf.format(date); // 将 Date 型变为了 String 型 // 输出：2018-10-19 00:29:56:400 System.out.println(str); String str_date = \"2018-10-19 00:29:56:400\"; try { Date date_str = sdf.parse(str_date); // 将String 型数据转化成 Date 型 System.out.println(date_str); } catch (ParseException e) { e.printStackTrace(); } }} 注意： 在将给定字符串转化为日期类型数据时，如果给定的月份不对会自动进行进位；但是如果与给定的转换格式不符，会抛出异常。 12// 输出：Tue Mar 19 00:29:56 CST 2019，年份进位String str_date = &quot;2018-15-19 00:29:56:400&quot;; 在\b数据表操作中说过几个常用类型：VARCHAR2(String)、CLOB(String)、Number(Double,int)、Date(java.util.Date) Date 与 String 的转换依靠的是 SimpleDateFormat； String 与基本类型的转换依靠的是包装类和 String.valueOf()方法 long 与 Date 的转换靠的是 Date 的构造方法和getTime() 方法。 3. Calendar 类主要进行一些简单的日期计算，是一个抽象类，依靠子类进行对象实例化操作。提供了一个 static 方法返回本类对象：public static Calendar getInstance()示例： 取得当前日期时间 12345678910111213141516import java.util.Calendar;public class TestDemo { public static void main(String[] agrs) { Calendar cal = Calendar.getInstance(); StringBuffer buf = new StringBuffer(); buf.append(cal.get(Calendar.YEAR)).append(\"-\"); // 添加年份 buf.append(cal.get(Calendar.MONTH) + 1 ).append(\"-\"); // 添加月，因为月从 0 开始，因此要 +1 buf.append(cal.get(Calendar.DAY_OF_MONTH)).append(\" \"); //添加日 buf.append(cal.get(Calendar.HOUR_OF_DAY)).append(\":\"); //添加时 HOUR_OF_DAY 表示 0-23 形式，HOUR表示1-24形式。 buf.append(cal.get(Calendar.MINUTE)).append(\":\"); // 添加分 buf.append(cal.get(Calendar.SECOND)); // 添加秒 // output: 2018-10-19 1:2:34 System.out.println(buf); }} Calendar 类在取得时可以进行一些简单的计算，比如获得三天后的日期等。比使用 Date 类计算简单，Date 类需要使用 long。 4. 总结 以后数据库中的日期型使用 java.util.Date 类表示； 代码模型：SimpleDateFormat 类实现了 String 类与 Date 类之间的互相转换。","link":"/2018/10/24/Java_44_日期操作类/"},{"title":"Chapter 43 数字操作类","text":"重点学习大浮点数 BigDecimal 类的使用，实现准确的四舍五入操作 数字操作类1. Math 类Math 类是一个专门进行数学计算的操作类\b，提供了一系列的数学计算方法。Math 类中提供的方法都是 static 型的，因为 Math没有普通属性，(属性：Math.E、Math.PI)。重点方法 四舍五入：public static long round(double a)long 比 int 的保存范围大， int 可能会发生溢出。注意： 传入负数时，大于 0.5 才进位，小于等于 0.5 不进位 123Math.round(15.5) // output:16Math.round(-15.5) // output:-15Math.round(-15.51) // output:-16 2. Random 类取得随机数的操作类，Random 在 java.util 包下。示例1： 产生 10 个不大于 100 的正整数 12345678910import java.util.Random;public class TestDemo { public static void main(String[] agrs){ Random rand = new Random(); for(int i =0 ;i &lt; 10; i++){ System.out.print(rand.nextInt(100) + \"、\"); } }} 示例2：产生36 选 7的功能，边界值为 37，不能有 0 或者重复的数据 12345678910111213141516171819202122232425262728293031323334353637import java.util.Random;public class TestDemo { public static void main(String[] agrs) { Random rand = new Random(); int[] data = new int[7]; // 开辟一个 7 元素的数组 int foot = 0; // 此为数组操作脚标 while (foot &lt; 7){ // 不知道循环多少次，所以使用 while 循环 int num = rand.nextInt(37); if(!isRepeat(data,num)){ data[ foot++ ] = num; } } java.util.Arrays.sort(data); // 按序输出，更清晰 for(int i = 0; i &lt; 7; i++){ System.out.print(data[i]+\"、\"); } } /** * 此方法主要是判断是否有重复数据，但是不允许保存 0 * @param temp 指已经保存的数据 * @param num 指新生成的数据 * @return 如果存在则返回 true，不存在则返回 false */ public static boolean isRepeat(int[] temp, int num){ if(num == 0){ return true; } for(int i = 0; i &lt; temp.length; i++){ if(temp[i] == num){ return true; } } return false; }} 3. 大整数操作类：BigInteger 类如果有两个很大的数字要进行数字计算（超出 double 的范围） 12345public class TestDemo { public static void main(String[] agrs) { System.out.println(Double.MAX_VALUE*Double.MAX_VALUE); // 输出为 Infinity }} 思考：这种情况该怎么做：超过 double 的范围那么只能用 String 保存，然后按位取出每一个字符保存的数据进行计算。考虑到这种情况 Java 提供了 BigInteger、BigDecimal 两种大数字操作类。BigInteger 的构造方法：public BigInteger(String val)示例： BigInteger 对象之间的加减乘除操作 1234567891011121314import java.math.BigInteger;public class TestDemo { public static void main(String[] agrs) { BigInteger bigA = new BigInteger(\"232435784545847598\"); BigInteger bigB = new BigInteger(\"2444545345431\"); System.out.println(\"加法操作：\" + bigA.add(bigB)); System.out.println(\"减法操作：\" + bigA.subtract(bigB)); System.out.println(\"乘法操作：\" + bigA.multiply(bigB)); System.out.println(\"除法操作：\" + bigA.divide(bigB)); //结果为整数 // 数组里面有两个元素，第一个元素表示商，第二个元素表示余数 BigInteger result[] = bigA.divideAndRemainder(bigB); System.out.println(\"商是：\" + result[0] + \"、余数是：\" + result[1]); }} 4. 大浮点数：BigDecimal（重点）BigInteger 不能保存小数，BigDecimal\b 可以保存小数。BigDecimal 的构造方法： 构造\b一：public BigDecimal(String val) 构造二：public BigDecimal(double val)与 BigInteger 一样，BigDecimal 也支持基础的数学运算，但是 BigDecimal 能实现准确的四舍五入操作。 Math.round() 方法中所有的小\b\b数都被丢弃了。BigDecimal 提供了一个除法 ： public BigDecimal divide(BigDecimal divisor,int scale,int roundingMode) BigDecimal divisor :被除数； int\b scale: 保留的小数位； int roundingMode：进位模式（public static final int ROUND_HALF_UP 这个常量描述的就是四舍五入的进位模式） 范例： 实现准确的四舍五入 12345678910111213141516171819202122232425import java.math.BigDecimal;class MyMath{ /** * 实现准确位数的四舍五入操作 * @param num 要进行四舍五入操作的数字 * @param scale 要保留的小数位 * @return 处理后的四舍五入数据 */ public static double round(double num,int scale){ BigDecimal bigA= new BigDecimal(num); BigDecimal bigB = new BigDecimal(1); // bigA.divide(...)类型是 BigDecimal // BigDecimal 是 Number的子类，可以找到 doubleValue() 方法返回 double 值 return bigA.divide(bigB,scale,BigDecimal.ROUND_HALF_UP).doubleValue(); }}public class TestDemo { public static void main(String[] agrs) { double num = 24.458748537; System.out.println(MyMath.round(num,2)); System.out.println(MyMath.round(15.5,0)); // 结果为 16 System.out.println(MyMath.round(-15.5,0)); // 结果为 -16 }} 此类操作的功能在日后开发中一定会使用，属于工具类的支持范畴。","link":"/2018/10/24/Java_43_数字操作类/"},{"title":"Chapter 45 比较器","text":"学习使用比较器 Comparable 接口。 比较器1. Arrays 类（了解）之前使用的 java.util.Arrays.sort()可以实现数组的排序，Arrays 是 java.util 包中提供的工具类，主要完成与数组有关的操作功能。 该类提供了二分查找方法：public static int binarySearch(数据类型[] a, 数据类型 key)，二分查找的前提：数组有序 示例：二分查找的实现 12345678910import java.util.Arrays;public class TestDemo { public static void main(String[] agrs) { int[] data = new int[]{1,3,2,9,6,5,10}; java.util.Arrays.sort(data); // 输出 5 ，非负表示查找到了 System.out.println(Arrays.binarySearch(data,9)); }} 提供了数组比较： public static boolean equals(数据类型[] a,数据类型[] b), 注意 与 Object 类中的 equals() 方法无关。要想判断数组是否相同，需要顺序完全一致 示例： 判断数组是否相等 12345678910import java.util.Arrays;public class TestDemo { public static void main(String[] agrs) { int[] dataA = new int[]{1,2,3}; int[] dataB = new int[]{1,2,3}; // dataA 与 dataB 数据相同且顺序相同输出 true，否则输出false System.out.println(Arrays.equals(dataA,dataB)); }} 其他操作： 填充数组: public static void fill(数据类型[] a, 数据类型 val); 将数组变为字符串输出：public static String toString(数据类型[] a)。 举例：*12345678910import java.util.Arrays;public class TestDemo { public static void main(String[] agrs) { int[] data = new int[10]; Arrays.fill(data, 5); // 输出：[5, 5, 5, 5, 5, 5, 5, 5, 5, 5] System.out.println(Arrays.toString(data)); }} 2. 比较器 Comparable（核心）比较的规则是由 Comparable 接口定义的，接口定义如下： 123public interface Comparable&lt;T&gt;{ public int compareTo(T o);} 实际上，String 类就是 Comparable 接口的子类，之前使用的 compareTo() 方法就是比较的操作功能。建议 compareTo() 返回三类数据： 1（）大于、0（等于）、-1（小于）。compareTo() 方法由 Array.sort() 自动调用。只需要\b覆写 compareTo 方法即可。示例： 比较器的使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Arrays;class Book implements Comparable&lt;Book&gt;{ private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } @Override public String toString() { return \"书名：\" + this.title + \"、价格：\" + this.price + \"\\n\"; } @Override public int compareTo(Book o) { if(this.price &gt; o.price){ return 1; } else if(this.price == o.price){ return 0; } else{ return -1; } }}public class TestDemo { public static void main(String[] agrs) { Book[] books = new Book[]{ new Book(\"Java开发\",79.8), new Book(\"JSP开发\",69.8), new Book(\"Oracle开发\",99.8), new Book(\"Android开发\",89.8) }; Arrays.sort(books);// 输出： [书名：JSP开发、价格：69.8// , 书名：Java开发、价格：79.8// , 书名：Android开发、价格：89.8// , 书名：Oracle开发、价格：99.8// ] System.out.println(Arrays.toString(books)); }} 总结： 在任何情况下，一组对象要排序，那么对象所在的类一定要实现 Comparable 接口。 3. 二叉树的实现 - BinaryTree (了解)树是一种比链表更为复杂的概念应用，本质也属于动态对象数组，与链表不同：树的最大特征是可以根据数据进行排序。树的操作原理：选择第一个数据作为根节点，比根节点小的数据放在左子树（左节点），比根节点大的数据放在右子树（右节点），取的时候按照中序遍历的方式取出（左-中-右）。任何数据的 Node 类的核心功能是保存\b真实数据和配置节点关系。 示例： 定义二叉树 定义出要使用的数据，数据所在的类需要实现 Comparable 接口； 123456789101112131415161718192021222324252627class Book implements Comparable&lt;Book&gt;{ private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } @Override public String toString() { return \"书名：\" + this.title + \"、价格：\" + this.price + \"\\n\"; } @Override public int compareTo(Book o) { if(this.price &gt; o.price){ return 1; } else if(this.price == o.price){ return 0; } else{ return -1; } }} 定义二叉树，所有的数据结构都需要有 Node 类的支持。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class BinaryTree{ private class Node{ private Comparable data; // 排序的依据就是 Comparable private Node left; // 保存左节点 private Node right; // 保存右节点 public Node(Comparable data) { this.data = data; } public void addNode(Node newNode){ if(this.data.compareTo(newNode.data) &gt; 0){ if(this.left == null){ this.left = newNode; } else{ this.left.addNode(newNode); } } else{ if(this.right == null){ this.right = newNode; } else{ this.right.addNode(newNode); } } } public void toArrayNode(){ if(this.left != null){ // 表示有左节点 this.left.toArrayNode(); } BinaryTree.this.retDate[BinaryTree.this.foot++] = this.data; if(this.right != null){ // 右子树输出 this.right.toArrayNode(); } } } private Node root; // 定义根节点 private int count = 0; // 定义二叉树节点个数 private Object[] retDate; private int foot = 0; public void add(Object obj){ // 进行数据追加 Comparable com = (Comparable) obj; // 必须变为 Comparable 才可以实现 Node 保存 Node newNode = new Node(com); // 创建新节点 if(this.root == null){ // 现在不存在根节点 this.root = newNode; // 保存根节点 } else{ this.root.addNode(newNode); // 交给 Node 类处理 } this.count ++; // 追加成功，二叉树的节点个数增加 } public Object[] toArray(){ if(this.root == null){ return null; } this.foot = 0; this.retDate = new Object[count]; this.root.toArrayNode(); return this.retDate; }}public class TestDemo { public static void main(String[] agrs) { BinaryTree bt = new BinaryTree(); bt.add(new Book(\"Java开发\",79.8)); bt.add(new Book(\"JSP开发\",69.8)); bt.add(new Book(\"Oracle开发\",99.8)); bt.add(new Book(\"Android开发\",89.8)); //下面两行和最后一行等价// Object[] obj = bt.toArray();// System.out.println(Arrays.toString(obj)); System.out.println(Arrays.toString(bt.toArray())); }} 以上这些内容，Java 的类库都有自己的实现。 挽救的比较器：Comparator 接口（了解，基本不使用）由于设置初期没有安排某类对象数组的排序（该类没有实现 Comparable 接口），在不改变该类的情况下，如何实现对象数组排序功能。\b针对该问题，Java 提供了一个比较器： java.util.Comparator。原本的 Comparator 中定义了两个方法：只需要实现其中的 compare() 方法。 12345@FunctionalInterfacepublic interface Comparator&lt;T&gt;{ public int compare(T o1, T o2); public boolean equals(Object obj);} \b解决方法：单独准备一个类来实现 Comparator 接口，这个类将作为指定类的排序类。范例： 定义排序的工具类 123456789101112131415161718```之前使用 Comparable \b接口是利用的是 Arrays.sort() 方法，现在我们使用另一个被重载的 sort() 方法。 `public static &lt;T&gt; void sort(T[] a,Comparable &lt;? super T&gt; c)` (&lt;? super T&gt;设置了泛型的下限，找的一定是 Book 类或者它的父类) **示例**\b：实现对象数组的排序``` javapublic class TestDemo { public static void main(String[] agrs) { Book[] books = new Book[]{ new Book(\"Java开发\",79.8), new Book(\"JSP开发\",69.8), new Book(\"Oracle开发\",99.8), new Book(\"Android开发\",89.8) }; Arrays.sort(books,new BookComparator()); System.out.println(Arrays.toString(books)); }} 可以看出，Comparator 实现对象数组排序较为麻烦，需要定义一个专门的排序类并且指明一个排序规则类。 问题 ：请解释两种比较器的区别（\bComparable 和 Comparator） 如果对象数组要进行排序那么必须设置排序规则，可以使用 Comparator 或 Comparable。 java.util.Comparable 是一个在类定义时实现好的接口，这样本类对象数组就可以进行排序，在 Comparable 接口下定义有 public int compareTo() 方法； java.util.Comparator 是专门定义一个类的比较规则，属于挽救的比较操作，其中有两个方法 compare() 和 equals()。equals()方法一般不关注。","link":"/2018/10/24/Java_45_比较器/"},{"title":"Chapter 46 正则表达式","text":"学会使用正则表达式，正则表达式在 String 类型数据的应用 正则表达式示例： 判断一个字符串是否全由数字组成 不使用正则表达式的形式 12345678910111213141516public class TestDemo { public static void main(String[] agrs) { String str = \"123\"; System.out.println(isNumber(str)); } public static boolean isNumber(String str){ char[] data = str.toCharArray(); // 1. 将字符串转换为字符数组 for(int i = 0; i &lt; data.length; i++){ // 2. 对字符数组中的每个元素进行判断 if(data[i] &gt; '9' || data[i] &lt; '0'){ return false; } } return true; }} 使用正则表达式的形式 123456public class TestDemo { public static void main(String[] agrs) { String str = \"123\"; System.out.println(str.matches(\"\\\\d+\")); }} 正则支持的类都定义在 java.util.regex 包里，该包定义了两个主要的类： Pattern 类：此类对象要想取得必须使用 compile() 方法，方法的功能是编译正则（正则类对象要想取得，必须先编译）。 Matcher 类：通过 Pattern 类取得。 2. 正则标记（必须记住）所有的正则标记都在 java.util.regex.Pattern 类中定义。 单个字符（数量：1） 字符：表示由一位字符所组成； \\\\：表示转义字符 “\\” ； \\t：表示一个 “\\t”； \\n：匹配换行（\\n）符号 字符集（数量：1） [abc]：表示可能是字符‘a’，字符‘b’，字符‘c’中的任意一位； [^abc]：表示不是a、b\b、c中的任意一位 [\ba-z]：所有的小写字母 [a-zA-Z]：表示任意的一位字母，不区分大小写 [0-9]：表示任意一位数字 简化的字符集表达式（数量：1） . ：表示任意\b一位字符 \\d：等价于“[0-9]”，属于简化写法； \\D：等价于“[^0-9]”，属于简化写法； \\s：表示任意的空白字符，例如“\\t”，“\\n”； \\S：表示任意的非空白字符； \\w：等价于“[a-zA-Z_0-9]”，表示由任意的字母、数字和下划线_所组成 \\W：等价于“[^a-zA-Z_0-9]”，表示不是由任意的字母、数字和下划线_所组成 边界匹配（不要在 Java 中使用，应该在 JavaScript 中使用） ^：正则的开始； $：整则的结束。 数量表达 正则?：表示此正则可以出现 0 次或 1 次； 正则+：表示此正则可以出现 1 次或 1 次以上； 正则*：表示此正则可以出现 0 次、 1 次或 1 次以上； 正则{n}：表示此正则正好出现 n 次； 正则{n,}：表示此正则可以出现 n 次以上(包括 n 次)； 正则{n,m}：表示此正则可以出现 n~m 次，包含 n、m。 逻辑运算 正则 1 正则 2：正则 1 判断完成之后继续判断正则 2； 正则 1 |正则 2：正则 1 或者正则 2 有一组满足即可； (正则)：将多个正则作为一组，可以为这一组单独设置出现的次数。 3. String 类对正则的支持（重点）String 中支持正则的几个方法：No.|\b方法名称|\b类型|描述|:-:|:-:|:-:|:-:|\b1|public boolean matches(String regex)|普通|正则验证，使用指定的字符串验证其是否符合给出的正则表达式结构|2|public String replaceAll（String regex,String replacement|普通|全部替换|3|public String replaceFirst(String regex,String replacement)|普通|替换首个|4|public String[] split(String regex)|普通|全部拆分|5|public String[] split(String regex,int limit)|普通|部分拆分| 示例： 保留字符串中的字母 12345678public class TestDemo { public static void main(String[] agrs) { String str = \"dfh23nf-;';dfha[.jehrywbm33;r\"; String regex = \"[^a-z]\"; // 输出 dfhnfdfhajehrywbmr System.out.println(str.replaceAll(regex,\"\")); }} 示例：字符串拆分 12345678910public class TestDemo { public static void main(String[] agrs) { String str = \"fdfdh223njdfjd3jsb433fn\"; String regex = \"\\\\d+\"; // [0-9]+ String result[] = str.split(regex); for(int i = 0; i &lt; result.length; i++){ System.out.println(result[i]); } }} 示例：验证一个字符串是否是数字，如果是将\b其转换为 double。（考虑整数：10，小数：10.2，不规范的数字：10. ） 12345678910public class TestDemo { public static void main(String[] agrs) { String str = &quot;1.0&quot;; String regex = &quot;\\\\d+(\\\\.\\\\d+)?&quot;; // [0-9]+ System.out.println(str.matches(regex)); if(str.matches(regex)){ // 转型之前要进行验证 System.out.println(Double.parseDouble(str)); } }} 示例：判断一个给定的字符串是否是 IP 地址（IPV4）IP 地址：192.168.1.1，每一段的最大是三个长度（1~3个长度都可以） 12345678public class TestDemo { public static void main(String[] agrs) { String str = \"192.110.1.1\"; //String regex = \"\\\\d{1,3}(\\\\.\\\\d{1,3}){3}\"; String regex = \"(\\\\d{1,3}\\\\.){3}\\\\d{1,3}\"; System.out.println(str.matches(regex)); }} 示例：给定一个字符串，判断其是否是日期格式，如果是的话转换为 Date 型数据 123456789101112131415public class TestDemo { public static void main(String[] agrs) { String str = \"2009-10-01\"; String regex = \"\\\\d{4}-\\\\d{2}-\\\\d{2}\"; System.out.println(str.matches(regex)); if(str.matches(regex)){ try { Date date = new SimpleDateFormat(\"yyyy-MM-dd\").parse(str); System.out.println(date); } catch (ParseException e) { e.printStackTrace(); } } }} 示例：判断电话号码，一般要编写电话号码以下几种格式都是满足的： 格式一：51283346 |- “\\d{7,8}” 格式二：010-51283346 |- “(\\d{3,4}-)?\\d{7,8}” 格式三：(010)-51283346 |- “((\\d{3,4}-)|(\\(\\d{3,4}\\)-))?\\d{7,8}”12345678910111213public class TestDemo { public static void main(String[] agrs) { String str1 = \"51283346\"; String str2 = \"010-51283346\"; String str3 = \"(010)-51283346\"; String str4 = \"(010)-010-51283346\"; String regex = \"((\\\\d{3,4}-)|(\\\\(\\\\d{3,4}\\\\)-))?\\\\d{7,8}\"; System.out.println(str1.matches(regex)); // true System.out.println(str2.matches(regex)); // true System.out.println(str3.matches(regex)); // true System.out.println(str4.matches(regex)); // false }} 示例：验证 E-mail 地址 要求格式一：email 由字母、数字、_所组成“\\w+@\\w+.\\w+” 要求格式二：用户名由字母、数字、_、. 组成，按长度最多为32，其中必须以字母开头，字母和数字结尾，根域名只能是 .com、.cn、 .net、 .com.cn、 .net.cn、 .edu、 .gov .org.1234567public class TestDemo { public static void main(String[] agrs) { String str1 = \"hello._nihao123@mdln.com.cn\"; String regex = \"[a-zA-z]+[a-zA-Z0-9_\\\\.]{0,28}[a-zA-z0-9]+@\\\\w+\\\\.(com|cn|net|com.cn|net.cn|edu|gov|org)\"; System.out.println(str1.matches(regex)); // true }} 需要分块，多次写，要细心和耐心。但是我代码在实验时： (\\w\\.) 与 [\\w\\.]不同，后者与[a-zA-Z0-9_\\.]等价（由数组、字母、_、. 组成），前者将\\w与.当做一体，如果有.，那么这部分判断就结束了。 [a-zA-Z0-9_\\.] 中 . 可以不需要转义 4. java.util.regex 的支持\b很多正则方法都是用 String 类中的方法完成了。我们了解一下 java.util.regex 中的两个类的使用。示例：Pattern 123456789101112import java.util.regex.Pattern;public class TestDemo { public static void main(String[] agrs) { String str = \"dfha23jhfj3sfj423ndnkdk\"; String regex = \"\\\\d+\"; Pattern pattern = Pattern.compile(regex); // 编译正则 String result[] = pattern.split(str); // 拆分字符串 for(int i = 0 ;i &lt; result.length; i++){ System.out.println(result[i]); } }} 示例：字符串验证 1234567891011import java.util.regex.Matcher;import java.util.regex.Pattern;public class TestDemo { public static void main(String[] agrs) { String str = \"1243435\"; String regex = \"\\\\d+\"; Pattern pattern = Pattern.compile(regex); // 编译正则 Matcher mat = pattern.matcher(str); // 进行正则匹配 System.out.println(mat.matches()); // 输出匹配结果 }} 因为 String 类本身就支持这样两种操作了，因此很少使用 Pattern 和 Matcher。","link":"/2018/10/24/Java_46_正则表达式/"},{"title":"Chapter 49 文件操作类","text":"进行所有的文件或者文件内容的开发操作 文件操作类1. 基本操作学习原则：抽象类中定义的抽象方法会根据实例化子类的不同，完成不同的功能。使用 File 类进行文件的操作。如果想要进行所有的文件或者文件内容的开发操作，需要使用 java.io 包完成，这个包中包含五个核心类以及一个核心接口： 五个核心类：File、InputStream、OutputStream、Reader、Writer； 一个核心接口：Serializable。在 java.io 包\b中，File 类是唯一一个与文件本身操作有关的类，但不涉及到文件的具体内容。文件的本身指的是文件的创建删除等操作。 使用 File，首先要根据它提供的构造方法定义一个要操作的文件的路径： 【重点】设置完整的路径：public File(String pathname)，大部分情况下使用此操作； 设置父路径和子文件：public File(File parent,String child)，在 Android 开发中使用比较多。 示例：操作文件 创建文件：public boolean createNewFile() throws IOException 抛异常的原因： 目录不能访问 文件重名，或者文件名称错误 【重要】判断文件是否存在：public boolean exists() 【重要】删除文件：public boolean delete()123456789101112package com.company;import java.io.File;public class TestDemo { public static void main(String[] agrs) throws Exception{ // 处理异常 File file = new File(\"./test.txt\"); if(file.exists()){ // 如果文件存在则删除 file.delete(); }else{ // 文件不存在则创建 System.out.println(file.createNewFile()); } }} Windows 下使用 “\\” \b作为路径分隔符，Linux 下使用 “/” 路径分隔符； 在 File 中提供了一个常量：public static final String separator，注意是小写，全局常量应该全大写命名。 文件路径应改为：File file = new File(&quot;.&quot; + File.separator +&quot;test.txt&quot;); 在进行 java.io 操作过程中，会有延迟现象，因为现在是 JVM 间接调用操作系统的文件系统函数进行文件处理操作，所以中间会出现延迟情况。（不要快速删除创建） 2. File 类操作方法File file = new File(&quot;.&quot; + File.separator + &quot;demo&quot;+ File.separator +&quot;test.txt&quot;);如果创建文件路径中某个文件夹不存在，系统认为此时的路径无法使用，那么无法进行文件创建（例如 demo 文件夹不存在，创建失败）。因此需要判断要创建的父路径是否存在： 【重点】找到父路径：public File getParentFile(); 【重点】创建目录（多级目录）：public boolean mkdirs(); 示例*：找到父路径、创建目录。要注意 创建父路径， file.mkdirs() 会将子文件也创建。12345678910111213141516171819package com.company;import java.io.File;public class TestDemo { public static void main(String[] agrs) throws Exception{ // 处理异常 File file = new File(\".\" + File.separator +\"filetest\" + File.separator +\"demo\"+ File.separator+\"test.txt\"); if(!file.getParentFile().exists()){ // 父路径不存在 //file.mkdirs(); // 创建父路径以及子文件 file.getParentFile().mkdirs(); // 创建父路径 System.out.println(\"路径创建完成\"); } if(file.exists()){ // 如果文件存在则删除 file.delete(); System.out.println(\"删除完成\"); }else{ // 文件不存在则创建 System.out.println(file.createNewFile()); System.out.println(\"文件创建完成\"); } }} File 中还有一些取得文件信息内容的操作功能： 取得文件大小：public long length()，long 型用来表示时间、日期、内存大小，返回结果为字节 判断是否是文件：public boolean isFile() 判断是否是目录：public boolean isDirectory() 最近一次修改时间：public long lastModified() 其他操作：getPath()、getName()、getTotalSpace()123456789101112131415161718192021222324package com.company;import java.io.File;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;public class TestDemo { public static void main(String[] agrs) throws Exception{ // 处理异常 File file = new File(\".\"+File.separator+\"DSC01450.JPG\"); if(file.exists()) { // 如果文件存在则进行文件大小判断 System.out.println(\"是否是文件：\"+file.isFile()); System.out.println(\"是否是目录：\"+file.isDirectory()); // System.out.println(\"文件大小为：\" + file.length()); // 单位为字节 System.out.println(\"文件大小为：\" + new BigDecimal((double) file.length() / 1024 / 1024).divide (new BigDecimal(1),2,BigDecimal.ROUND_HALF_UP)+\"M\"); // 单位为 M // System.out.println(\"上一次修改时间为：\"+file.lastModified()); // 单位为 ms // System.out.println(\"上一次修改时间为：\"+ new Date(file.lastModified())); // 单位为 Date 类型的形式 System.out.println(\"上一次修改时间为：\"+ new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date(file.lastModified()))); } else{ System.out.println(\"文件不存在\"); } }} 3. 操作目录File 类中定义了两个列出目录的方法： 列出目录的信息：public String[] list()，列出的是目录下的子目录或者文件的名字 列出所有的信息以及 File 类的包装：public File[] listFile()，取得文件对象列表会更加方便，因为可以继续取出很多内容。 示例*：按照资源管理器的形式输出路径下的文件名/文件夹名称、创建时间、类型、大小。123456789101112131415161718192021222324252627package com.company;import java.io.File;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;public class TestDemo { public static void main(String[] agrs) throws Exception{ // 处理异常 File file = new File(\"/Users\"+File.separator + \"fjiao\"); if(file.isDirectory()) { // 判断是不是目录 File[] result = file.listFiles(); for(int i = 0; i &lt; result.length; i++){// System.out.println(result[i]);// 写成资源管理器的格式 以下为输出举例// 毕业照 2018-03-18 19:19:19 文件夹 // 论文5.18日格式完成.docx 2018-05-29 15:15:27 文件 4.38 System.out.println(result[i].getName()+\"\\t\\t\\t\" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date(result[i].lastModified())) + \"\\t\\t\" + (result[i].isDirectory()?\"文件夹\":\"文件\") + \"\\t\\t\" + (result[i].isFile()?new BigDecimal((double)result[i].length()/1014/1024).divide(new BigDecimal(1),2, BigDecimal.ROUND_HALF_UP):\"\") ); } } }} 思考题：列出指定目录下的所有子路径 原则：如果现在给定的路径依然是一个目录，那么向里继续列出所有组成，应该使用递归的方式完成。1234567891011121314151617181920212223package com.company;import java.io.File;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 File file = new File(\"/Users\" + File.separator + \"fjiao\"+File.separator +\"IDEA\"); print(file); } public static void print(File file){ if(file.isDirectory()){ File result[] = file.listFiles(); if(result != null){ // 已经可以列出的目录，不会列出隐藏文件 for(int i = 0;i &lt; result.length; i++){ print(result[i]); } } } System.out.println(file); //file.delete(); //删除文件的恶性操作 }} 4. 总结 File 类本身是操作文件的，不涉及到内容 File 类中的重要方法： 设置完整的路径：public File(String pathname) 删除文件：public boolean delete() 判断文件是否存在：public boolean exists() 找到父路径：public File getParentFile(); 创建目录（多级目录）：public boolean mkdirs(); 在使用 File 类操作的时候路径的分隔符使用：File.separator","link":"/2018/10/24/Java_49_文件操作类/"},{"title":"Chapter 53 System 类对 IO 的支持","text":"在 System 类里面为了支持 IO 操作专门提供有三个常量：错误输出、输出到标准输出设备（显示器）、从标准输入设备读取（键盘）等基础实现和用法 System 类对 IO 的支持（了解）1. 输出在 System 类里面为了支持 IO 操作专门提供有三个常量： 错误输出：public static final PrintStream err; 输出到标准输出设备（显示器）：public static final PrintStream out; 从标准输入设备读取（键盘）：public static final InputStream in; 1.1 错误输出（没用） System.err 是 PrintStream 的类，此类专门进行错误信息的输出操作： 1234567891011121314package com.company;public class TestDemo { public static void main(String[] agrs){ try{ Integer.parseInt(\"abc\"); }catch(Exception e){ // 两个输出一样，颜色不一样： // java.lang.NumberFormatException: For input string: \"abc\" System.err.println(e); System.out.println(e); } }} 严格来讲，System.err 和 System.out 输出的错误是一样的，System.err 输出不让用户看到的错误信息，System.out 输出可以让用户看到的信息，但是现在已经不做区分了。 1.2 信息输出（System.out） System.out 是 Java 中专门准备的支持屏幕输出\b信息的操作对象（此对象由系统负责实例化），使用 Sytem.out 实现一个简单的输出操作System.out 是 PrintStream 的对象， PrintStream 是 OutputStream 的子类，因此示例使用 OutputStream 进行屏幕输出 1234567891011package com.company;import java.io.IOException;import java.io.OutputStream;public class TestDemo { public static void main(String[] agrs) throws IOException { // OutputStream 变为了屏幕输出 OutputStream out = System.out; // 屏幕输出 out.write(\"Hello, world!\".getBytes()); }} 以上代码，体现了 Java 的多态性。根据实例化子类的不同，选择不同的方法。结合 JDK 1.8 的函数式\b功能接口，它可以为消费型函数式接口做方法引用。 123456789package com.company;import java.util.function.Consumer;public class TestDemo { public static void main(String[] agrs) { Consumer&lt;String&gt; con = System.out :: println; // 屏幕输出 con.accept(\"Hello, world!\"); }} Java 系统里，System.out 是系统默认提供好的实例化对象，不需要用户进行明确的实例化操作。但是文件、内存需要进行明确的实例化操作。 2. 系统输入 System.in（不使用）Java 类中有一个 in 的对象，类型为 InputStream。 123456789101112package com.company;import java.io.IOException;import java.io.InputStream;public class TestDemo { public static void main(String[] agrs) throws IOException { InputStream in = System.in; byte data[] = new byte[1024]; System.out.println(\"请输入数据：\"); int len = in.read(data); System.out.println(\"输入的数据为：\" + new String(data,0,len) ); }} 与之前最大的不同，只是更换了一个实例化对象。存在的问题：超过数组长度的数据将不会被保存。想办法解决长度限制： 123456789101112131415161718package com.company;import java.io.IOException;import java.io.InputStream;public class TestDemo { public static void main(String[] agrs) throws IOException { InputStream in = System.in; StringBuffer buf = new StringBuffer(); System.out.println(\"请输入数据：\"); int temp = 0; while((temp = in.read()) != -1){ if(temp == '\\n'){ break; } buf.append((char)temp); } System.out.println(\"输入的数据为：\" + buf ); }} 以上操作虽然没有了长度限制，但是依然无法使用，\b输入中文时成为乱码。一个中文两个字符，四个字节。 3. 总结System 类对于 IO 的各种操作并不会经常使用到，唯一可以使用到的也是 System.out.println() 之类的方法，对于此部分需要清楚一点：System.out 使用的是 PrintStream类对象进行标准输出设备的显示的。 【遗留问题】：中文怎么输入？","link":"/2018/10/24/Java_53_System对IO的支持/"},{"title":"Chapter 47 反射机制","text":"认识反射机制，反射实例化对象，使用反射调用构造，反射调用方法举例 反射机制1. 认识反射机制反：通过对象找到出处，在 Object 类里面会提供一个方法： 取得 class 对象:public final Class&lt;T&gt; getClass() 示例*: 取得 class 对象12345678import java.util.Date;public class TestDemo { public static void main(String[] agrs) { Date date = new Date(); // 输出：class java.util.Date System.out.println(date.getClass()); }} 对象调用 getClass() 方法后输出了类的完整名称，等于是找到了对象的出处，称为”反“。 2. Class 类对象实例化java.lang.Class 是一个类，这个类是反射类的源头，，即所有的反射类都要从此类开始，这个类有三种实例化方式： \b第一种：调用 Object 类中的 getClass() 方法。使用频率很低。 123456789import java.util.Date;public class TestDemo { public static void main(String[] agrs) { Date date = new Date(); Class&lt;?&gt; cla = date.getClass(); // 输出： class java.util.Date System.out.println(cla); }} 第二种：使用”\b类.class“ 取得，\b以后讲解 Hibemat、MyBatis、Spring 等使用。 12345678import java.util.Date;public class TestDemo { public static void main(String[] agrs) { Class&lt;?&gt; cla = Date.class; // 输出： class java.util.Date System.out.println(cla); }} 之前的方法是产生了类的实例化对象之后取得的 Class 类对象，这个方法没有实例化对象。 第三种：调用 Class 类提供的一个方法（重要）实例化 Class 类对象：public static Class&lt;?&gt;forName(String className)throws ClassNotFoundException123456789101112public class TestDemo { public static void main(String[] agrs) { Class&lt;?&gt; cla = null; try { cla = Class.forName(\"java.util.Date\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } // 输出： class java.util.Date System.out.println(cla); }} 异常的处理方式不同：这个更简洁 12345678public class TestDemo { public static void main(String[] agrs) throws Exception{ Class&lt;?&gt; cla = null; cla = Class.forName(\"java.util.Date\"); // 输出： class java.util.Date System.out.println(cla); }} 可以发现该方法不使用 import 语句导入一个明确的类，类名称是采用字符串的形式描述的。 3. 反射实例化对象使用反射类来实例化对象\b操作： 实例化对象方法：\bpublic T newInstance() throws XXXException12345678910public class TestDemo { public static void main(String[] agrs) throws Exception{ Class&lt;?&gt; cla = Class.forName(\"com.company.Book\"); Object obj = cla.newInstance(); Book book = (Book) obj; // 输出 obj 和 book 结果是一样的 //System.out.println(obj); System.out.println(book); }} 有了反射之后，以后进行对象实例化操作不再只是单独的依靠关键字 new 了，但这并不表示关键字 new 被完全代替了。new 是造成耦合的最大元凶，一切耦合都起源于 new。范例：观察工厂设计模式 123456789101112131415161718192021222324252627282930package com.company;interface Fruit{ public void eat();}class Apple implements Fruit{ public Apple() { } @Override public void eat() { System.out.println(\"*** 吃苹果\"); }}class Factory{ public static Fruit getInstance(String className){ if(\"apple\".equals(className)){ return new Apple(); } else { return null; } }}public class TestFactory { public static void main(String[] args){ Fruit f = Factory.getInstance(\"apple\"); f.eat(); }} 每增加一个类就要修改工厂类，因为工厂类中的对象都是通过关键 new 直接实例化的，new 就成为所有问题的关键点。想要解决这一问题，就要依靠反射完成。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.company;interface Fruit{ public void eat();}class Apple implements Fruit{ public Apple() { } @Override public void eat() { System.out.println(\"*** 吃苹果\"); }}class Orange implements Fruit{ public Orange() { } @Override public void eat() { System.out.println(\"*** 吃橘子\"); }}class Factory{ public static Fruit getInstance(String className){ Fruit f = null; try { f = (Fruit) Class.forName(className).newInstance(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } return f; }}public class TestFactory { public static void main(String[] args){ //Fruit f = Factory.getInstance(\"com.company.Apple\"); Fruit f = Factory.getInstance(\"com.company.Orange\"); f.eat(); }} 此时的程序真正完成了解耦合的目的，可扩展性非常强。 4. 使用反射调用构造以上反射机制实例化对象的方法都是使用无参构造，若类中没有无参构造，程序则会抛出 NoSuchMethodException 异常。这种情况下只能明确的调用有参方法。Class 类提供了一个方法可以取得\b构造 取出全部构造：public Constructor&lt;?&gt;[] getConstructors() throws XXXException 取得一个指定参数顺序的构造public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException以上两个方法返回的都是 “java.lang.reflect.Constructor” 类对象,这个类中提供一个明确传递有参内容的实例化对象方法，public T newInstance(Object ... initargs) throws XXXException 示例*：明确调用类中的有参构造1234567891011package com.company;import java.lang.reflect.Constructor;public class TestDemo { public static void main(String[] agrs) throws Exception{ Class&lt;?&gt; cla = Class.forName(\"com.mldn.demo.Book\"); //public Book(String title, double price) Constructor&lt;?&gt; con = cla.getConstructor(String.class,double.class); Object obj = con.newInstance(\"Java开发\",79.8); // 实例化对象 System.out.println(obj); }} 此操作很麻烦，所以前面说过：简单 Java 类的开发中不管有多少个构造方法，请至少保留无参构造方法 5. 反射调用方法类中的普通方法只有在一个类产生实例化对象之后才能调用，实例化对象的方式有三个： new，克隆，反射。Class 类中提供一下取得类中 Method 的操作 取得一个类中的全部方法：public Method[] getMethods() throws XXXEcxeption 取得指定方法：public Method getMethod(String name,Class&lt;?&gt; ...parameterType) throws XXXException 以上两个方法返回的都是 “java.lang.reflect.Method” 类的对象，这个类中重点关注一个方法： 调用方法：public Object invoke(Object obj,Object... args) throws XXXException 示例：反射调用方法定义Book类，其中包括无参构造方法、属性 title 和 price 的 setter 和 getter方法。 1234567891011121314151617181920package com.company;import java.lang.reflect.Method;public class TestDemo { public static void main(String[] agrs) throws Exception{ String fieldName = \"title\"; // 要操作的成员 Class&lt;?&gt; cla = Class.forName(\"com.mldn.demo.Book\"); Object obj = cla.newInstance(); // 必须给出实例化对象 Method getMet = cla.getMethod(\"get\" + initcap(fieldName)); Method setMet = cla.getMethod(\"set\" + initcap(fieldName),String.class); setMet.invoke(obj,\"Java开发\"); // 等价于 Book类对象.setTitle(\"Java开发\") System.out.println(getMet.invoke(obj)); } public static String initcap(String str){ // 首字母大写 return str.substring(0,1).toUpperCase() + str.substring(1); }} 此时完全看不到具体的操作类型，即利用反射可以实现任意类的指定方法调用。 6. 反射调用成员类中的属性一定要在本类实例化对象产生之后才可以分配内存空间。Class 类中提供取得成员的方法： 取得全部成员：public Field[] getDeclaredFields() throws SecurityException 取得指定成员：public Field getDeclaredField(String name) throws NoSunFieldException,SecurityException返回的类型是 java.lang.reflect.Field 类，这个类中有两个重要方法： 取得属性内容：public Object get(Object obj) throws XXXException 设置属性内容：public void set(Object obj,Object value) throws XXXException 在 Field 的父类 java.util.reflect.AccessibleObject类下面(JDK 1.8 之后修改)： Executable：下面继承了 Constructor,Method; Field这个类中提供了一个方法：public void setAccessible(bool flag) throws XXXException 注意*：如果不使用此方法取消封装，那么将无法访问私有属性 示例：提供 Book 类，类中有 private String title 属性，使用反射调用 123456789101112131415package com.company;import java.lang.reflect.Field;public class TestDemo { public static void main(String[] agrs) throws Exception{ String fieldName = \"title\"; // 要操作的成员 Class&lt;?&gt; cla = Class.forName(\"com.mldn.demo.Book\"); Object obj = cla.newInstance(); // 必须给出实例化对象 Field titleField = cla.getDeclaredField(fieldName); titleField.setAccessible(true); // 封装取消了 titleField.set(obj,\"Java开发\"); // 相当于 Book类对象.titile = \"Java开发\" System.out.println(titleField.get(obj)); // 相当于Book类对象.title }} 构造方法和普通方法同样也可以取消封装，只不过很少这样做，对于属性的访问最好使用 setter、getter 方法。","link":"/2018/10/24/Java_47_反射机制/"},{"title":"Chapter 48 国际化","text":"国际化程序的实现 国际化1. 国际化程序的实现程序是不会改变的，唯一可能改变的就是语言。如果想要实现语言的统一，唯一能够做的方式就是将所有需要显示的语言定义在各自的资源文件里面。所谓的国际化指的就是：根据当前的语言环境读取指定的语言资源文件。如果想实现国际化操作，首先要解决如何读取资源文件的问题。资源文件指的是后缀名称为 *.properties 里面保存的内容形式为 key=value，资源文件的命名标准与 Java 类完全一样。 示例：定义一个 Message.properties 文件 如果保存的是中文信息，那么必须将其变为 UNICODE 编码info=中国人民共和国这里面保存的 info 是这个信息的key，以后要根据这个 key 取得对应的value。如果读取资源文件的信息使用 java.util.ResourceBundle 类,这是一个抽象类，这个类的内部提供了一个 static 方法用于取得本类对象： 根据当前语言环境取出：public static ResourceBundle(String baseName); 设置指定语言环境：public static ResourceBundle(String baseName,Locale locale)baseName 指的是 “Message”，因为默认后缀为 *.properties 当取得了 ResourceBundle 类对象之后可以\b通过以下方法读取数据： 简单读取：public final String getString(String key) java.text 是专门国际化处理的程序包，这个包里有一个专门处理占位数据的操作类：MessageFormat 格式化文本：public static String format(String pattern,Object...arguments) 示例：读取普通文本 123456789101112package com.company;import java.util.ResourceBundle;public class TestDemo { public static void main(String[] agrs) throws Exception{ // 访问的时候一定不要加上后缀，默认后缀为 \"*.properties\" // 此时的 Message.properties 一定要放在 CLASSPATH 下，bin文件就在CLASSPATH下 ResourceBundle rb = ResourceBundle.getBundle(\"Message\"); System.out.println(rb.getString(\"info\")); }} 示例：修改 Message.properties 文件wel.msg=Hello {0},this time is{1}示例：设置读取的可变内容 123456789101112131415161718package com.company;import java.text.MessageFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.ResourceBundle;public class TestDemo { public static void main(String[] agrs) throws Exception{ // 访问的时候一定不要加上后缀，默认后缀为 \"*.properties\" // 此时的 Message.properties 一定要放在 CLASSPATH 下，bin文件就在CLASSPATH下 ResourceBundle rb = ResourceBundle.getBundle(\"Message\"); // str 的内容是 Hello {0},this time is{1} String str = rb.getString(\"wel.msg\"); // 具备有占位符的内容 // 输出：Hello Lily,this time is 2018-10-19. System.out.println(MessageFormat.format(str,\"Lily\", new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()))); }} 如果从事应用开发，那么只需要写好 Message.properties 文件即可。 国际化程序应该根据所在国家的不同显示不同的内容，提供一个语言资源文件，怎么进行不同语言内容显示。需要使用 Locale 类。Locale 保存的是一个国家的区域和语言编码 中国：zh_CN； 美国：en_US； 可以在定义资源文件时加上指定的语言编码 示例：定义中文的资源文件：Messages_zh_CN.propertieswel.meg=欢迎{0}光临！ 示例：定义英文的资源文件:Messages_en_US.propertieswel.msg=WELCOME {0} 设置的 baseName 一定是 Messages，所有的语言代码由 Locale 类进行设置，在 Locale 类中提供了如下方法： 构造方法：public Locale(String languages,String country) 取得当前语言环境：public static Locale getDefault() 示例：读取中文的资源文件 12345678910111213141516package com.company;import java.text.MessageFormat;import java.util.Locale;import java.util.ResourceBundle;public class TestDemo { public static void main(String[] agrs) throws Exception{ Locale loc = new Locale(\"zh\",\"CN\"); ResourceBundle rb = ResourceBundle.getBundle(\"Messages\",loc); String str = rb.getString(\"wel.msg\"); // 具备有占位符的内容 System.out.println(MessageFormat.format(str,\"我\")); //当前语言环境为 zh_CN System.out.println(Locale.getDefault()); }} 示例：读取英文的资源文件 12345678910111213141516package com.company;import java.text.MessageFormat;import java.util.Locale;import java.util.ResourceBundle;public class TestDemo { public static void main(String[] agrs) throws Exception{ Locale loc = new Locale(\"en\",\"US\"); ResourceBundle rb = ResourceBundle.getBundle(\"Messages\",loc); String str = rb.getString(\"wel.msg\"); // 具备有占位符的内容 System.out.println(MessageFormat.format(str,\"我\")); //当前语言环境为 zh_CN System.out.println(Locale.getDefault()); }} 如果存在\b特定的语言资源文件，那么不会读取其他没有设置语言资源的文件。特定语言资源文件的优先级高于\b公共语言资源文件的优先级。 2. 总结 资源文件：文件名称每个单词首字母大写，后缀必须是 *.properties; 通过 ResourceBundle 类可以读取在指定的 CLASSPATH 下的资源文件，读取时不需要输入文件后缀。动态的占位文本格式化：MessageFormat。 Locale 类用于指定读取的资源文件的语言环境。","link":"/2018/10/24/Java_48_国际化/"},{"title":"Chapter 52 打印流","text":"使用打印流支持各种数据类型的输出 打印流1. 问题引出OutputStream 输出 String\b 类需要将 String 类变为 字节数据（getBytes），\bint、double 类型都需要转换成 String 然后再变为字节数据。示例：创建一个类，支持各种数据类型的输出 123456789101112131415161718192021222324252627282930313233343536373839404142package com.company;import java.io.*;class PrintUtil{ private OutputStream output; public PrintUtil(OutputStream output){ this.output = output; } public void print(int x){ this.print(String.valueOf(x)); } public void print(String x){ try { this.output.write(x.getBytes()); } catch (IOException e) { e.printStackTrace(); } } public void print(double x){ this.print(String.valueOf(x)); } public void println(int x){ this.println(String.valueOf(x)); } public void println(String x){ this.print(x.concat(\"\\n\")); } public void println(double x){ this.println(String.valueOf(x)); }}public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 PrintUtil pu = new PrintUtil(new FileOutputStream(\".\" + File.separator + \"testA.txt\")); pu.print(5); pu.print(5.5); pu.print(\"Hello\"); pu.println(\"\"); pu.println(5); pu.println(5.5); pu.println(\"Hello\"); }} 2. 打印流为了解决输出数据时功能不足，java.io 提供了一套用于数据输出的类：PrintStream（打印字节流），PrintWriter（打印字符流）。这两个类除类名称不一样，方法是一样的，以 PrintStream 类为例，观察一下这个类的继承与构造方法： 1234java.lang.Object |- java.io.OutputStream |- java.io.FilterOutputStream |- java.io.PrintStream 构造方法：public PrintStream(OutputStream out) 在 PrintStream 类中，提供了一系列 print() 和 println() 方法，这些方法支持各种数据类型的输出，如果使用 PrintStream 就不需要使用 write() 方法。但本质依然是根据 OutputStream 类的方法完成的。这种设计模式成为装饰设计模式，相当于将一个功能不足的操作类，通过某些类的装饰，形成更好用的工具类。\b示例：使用 PrintStream 1234567891011121314package com.company;import java.io.*;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 PrintStream pu = new PrintStream(new FileOutputStream(\".\" + File.separator + \"testA.txt\")); pu.print(5); pu.print(5.5); pu.print(\"Hello\"); pu.println(\"\"); pu.println(5+2); pu.println(5.5+1.33); pu.println(\"Hello\"); }} 在以后的开发过程中，只要是程序输出内容，都采用打印流的模式，但要记住，打印流需要 OutputStream 类支持的。 3. JDK 1.5 改进 所有的输出数据都要求使用打印流输出，JDK 1.5 增加了新的输出：格式化输出：public PrintStream printf(String format,Object... args)如果需要格式化输出就需要一些标记：\b整数（%\bd），字符串（%s），字符（%c），小数（%m.nf） \b示例：格式化输出【了解】 1234567891011package com.company;import java.io.*;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 String name = \"Mary\"; int age = 18; double score = 59.89; PrintStream pu = new PrintStream(new FileOutputStream(\".\" + File.separator + \"testA.txt\")); pu.printf(\"姓名：%s \\n年龄：%d\\n成绩：%.2f\",name,age,score); }} JDK 1.5 之后 String 的改进String 定义了一个新的功能：格式化字符串public static String format(String format,Object... args) 示例：格式化字符串 1234567891011package com.company;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 String name = \"Mary\"; int age = 18; double score = 59.89; String str = String.format(\"姓名：%s \\n年龄：%d\\n成绩：%.2f\",name,age,score); System.out.printf(str); }} String 类的核心功能讲解完成啦。","link":"/2018/10/24/Java_52_打印流/"},{"title":"Chapter 51 IO 辅助概念","text":"字符编码和内存流的介绍。 IO 辅助概念1. 字符编码 工作中最常用的几种编码如下： GBK：中文的国标编码，其中 GBK 包含中文简体与繁体，但是 GBK2312 只包含简体。（有局限） ISO8859-1：中文的国际编码，可以描述任何文字信息 UNICODE：是十六进制编码，造成传输的无用数据过多 UTF 编码 (UTF-8) ：融合了 ISO8859-1 和 UNICODE 编码的特点。【重点】：所有的开发中，都使用 UTF-8 编码。 乱码本质：编码与解码的字符集方式不统一。 示例：列出所有的环境属性（不需要掌握） 123456package com.company;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 System.getProperties().list(System.out); }} 我这里的默认是：UTF-8，老师讲解的默认是 GBK示例：默认中文输出 1234567891011package com.company;import java.io.*;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 File file = new File(\".\" + File.separator + \"test.txt\"); OutputStream out = new FileOutputStream(file); out.write(\"今天也要加油鸭！\".getBytes()); out.close(); }} 若是强制转换为 ISO8859-1 编码，则会出现乱码情况 1out.write(\"今天也要加油鸭！\".getBytes(\"ISO8859-1\")); 总结： 所有的开发中，都使用 UTF-8 编码 乱码的本质是编码与解码的方式不统一 2. 内存流当学习到 AJAX + XML (JSON) 应用时才会牵扯到此部分 使用内存流实现 IO 操作。之前使用稳健操作流实现对文件数据的输入输出，如果现在需要进行 IO 操作，又不想产生文件，\b可以利用内存实现输入输出操作（内存流\b的意义）。 针对内存流，java.io 提供了两组操作： \b字节内存流（为主）：ByteArrayInputStream、ByteArrayOutputStream 字符内存流：CharArrayReader、CharArrayWriter。 ByteArrayInputStream 类： 继承结构： 123java.lang.Object |- java.io.InputStream |- java.io.ByteArrayInputStream 构造方法：public ByteArrayInputStream(byte[] buf) 表示将要操作的数据设置到输入流 ByteArrayOutputStream 继承结构： 123java.lang.Object |- java.io.OutputStream |- java.io.ByteArrayOutputStream 构造方法：public ByteArrayOutputStream(byte[] buf) 下面为了更好的说明问题，特别做一个举例： 以文件操作为例：|- 输出（OutputStream）：程序 -&gt; OutputStream -&gt; 文件；|- 输入（InputStream）：程序 &lt;- InputStream &lt;- 文件； 以内存操作为例：|- 输出（InputStream）：程序 -&gt; InputStream -&gt; 内存；|- 输入（OutputStream）：程序 &lt;- OutputStream &lt;- 内存； 示例：实现一个小写字母到大写字母的转换操作 为了方便的实现字母的转大写操作，避免不必要的字符也被转换了，可以借助 Character 类。|- public static char toLowerCase(char ch)|- public static int toLowerCase(int codePoint)，int 可以与 byte 转换|- public static char toUpperCase(char ch)|- public static int toLowerCase(int codePoint)1234567891011121314151617181920212223package com.company;import java.io.*;public class TestDemo { public static void main(String[] agrs) throws Exception { // 此处直接抛出 String str = \"Hello**World!!!\"; // 要求被转换的字符串 // 本次通过内存操作流实现转换，先将数据保存在内存流中，而后从里面取出每一个数据 // 将所有要读取得数据设置到内存输入流之中，本次利用向上转型 InputStream input = new ByteArrayInputStream(str.getBytes()); // 为了能将所有的内存流数据取出，使用 ByteArrayOutputStream OutputStream output = new ByteArrayOutputStream(); int temp = 0; // 读取每一个字节数据 // 经过此次循环之后，所有的数据都将保存在内存输出流对象中 while((temp = input.read())!= -1){ // 每次读取一个数据 output.write(Character.toUpperCase(temp)); // 字节输出流 } System.out.println(output); // 调用 toString() 方法 input.close(); output.close(); }} 以上的代码，所有的输入输出流都发生了向上转型，向上转型的好处是可以得到参数的统一。但不能忽略一个问题，每一个子类都有自己的功能。在 ByteArrayOutputStream 中有一个重要的方法：public byte[] toByteArray()，这个方法可以将所有保存在内存中的字节数据变为字节数组存在。利用 ByteArrayOutputStream 可以实现多个文件的同时读取：示例：文件的合并读取 12345678910111213141516171819202122232425262728package com.company;import java.io.*;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 File fileA = new File(\".\" + File.separator + \"testA.txt\"); File fileB = new File(\".\" + File.separator + \"testB.txt\"); InputStream inputA = new FileInputStream(fileA); InputStream inputB = new FileInputStream(fileB); ByteArrayOutputStream output = new ByteArrayOutputStream(); int temp = 0; // 每次读取一个字节 while((temp = inputA.read()) != -1){ output.write(temp); } while((temp = inputB.read()) != -1){ output.write(temp); } // 现在所有内容都存在了内存输出流中，所有内容变为自己数组输出 byte data[] = output.toByteArray(); output.close(); inputA.close(); inputB.close(); System.out.println(new String(data)); }} 对与 InputStream 和 OutputStream 又有了新的位置，其中以 ByteArrayOutputStream 最为重要。","link":"/2018/10/24/Java_51_IO辅助概念/"},{"title":"Chapter 55 网络编程","text":"网络编程的时代已经结束。讲解的目的是阐述网络操作的过程，这些过程将会直接影响到 JavaEE 的开发。 网络编程网络编程的时代已经结束。讲解的目的是阐述网络操作的过程，这些过程将会直接影响到 JavaEE 的开发。 1. 网络编程简介网络编程：进行服务器端与客服端编程的\b开发操作的实现。实际工作中对网络编程有两种形式： C / S 结构（Client / Server），此类开发需要编写两套程序，一套用于客户端、一套用于服务器。这样的程序开发非常麻烦，因为要维护两套程序的使用。优点是安全性高，因为使用的是自己的连接端口和通信协议。 B / S 结构（Browser / Server），此类开发只需要编写服务器端代码，不再开发单独的客服端代码，用户通过浏览器进行访问。但是安全性不高，因为使用的是公共的 HTTP 协议以及公共的 80 端口。 本次要讲解的网络编程是 C / S 程序开发，即要开发两套程序。这样的程序也可以成为 Socket 程序。分为两类： TCP 程序：是采用可靠的连接方式进行传输 UDP 程序：不可靠的连接，属于数据报协议 两类\b程序都不使用了，下面以 TCP 为例讲解 2. 基本实现想要进行网络编程开发，最为核心的两个类： 服务器类：\bServerSocket 类，主要工作在服务器端，用于接收用户的请求； 客户端类：Socket 类，每一个连接到服务器的用户都通过 Socket 表示； 示例\b：定义服务器端 ———— 主要使用 ServerSocket 类 构造方法：public ServerSocket(int port)throws IOException设置监听端口 接受客户端连接：public Socket accept()throws IOException 取得客户端输出功能，Socket \b定义的方法：public getOutputStream()throws IOException1234567891011121314151617import java.io.PrintStream;import java.net.ServerSocket;import java.net.Socket;public class HelloServer { public static void main(String[] args) throws Exception{ ServerSocket server = new ServerSocket(9999); System.out.print(\"等待客户端连接……\"); Socket client = server.accept(); // 等待客户端连接 // OutputStream 并不适合输出数据，所以使用打印流 PrintStream PrintStream out = new PrintStream(client.getOutputStream()); out.println(\"Hello,world！\"); out.close(); client.close(); server.close(); }} 服务器必须有端口，9000 左右的端口很少被占用。此时服务器输出 “Hello,world！” 就关闭了服务器操作了，只能处理一次 client 请求。 示例：编写客户端 ———— Socket 构造方法：public Socket(String host,int port) throws Unknown HostException,IOException|- host 代表主机的 IP 地址，如果市本级直接访问 localhost(217.0.0.1) 代替IP 得到输入数据：public InputStream getInputStream() throws IOException1234567891011121314151617import java.net.Socket;import java.util.Scanner;public class HelloClient { public static void main(String[] args)throws Exception{ // 连接服务器 Socket client = new Socket(\"localhost\",9999); // 取得客户端的输入数据流对象，表示接收服务器端的输出信息 Scanner scan = new Scanner(client.getInputStream()); scan.useDelimiter(\"\\n\"); if(scan.hasNext()){ System.out.println(\"【回应数据】：\" + scan.next()); } scan.close(); client.close(); }} 客户端现在也只是连接一次服务器，并且接收输入数据，输出后结束操作。 3. Echo 程序在网络编程中， ECHO 是一个经典的程序开发模型，客户端随意输入信息，并将信息发送给服务器，服务器接收后在前面加上一个 “ECHO:” 的标记返回。 设计如下： 由于需要采用多次输入的形式，所以不能每次连接后立刻关闭服务器 可以设置一个字符串，当输入了 “byebye”，那么表示结束本次的 ECHO 操作 示例：实现服务器端的代码 123456789101112131415161718192021222324252627282930import java.io.PrintStream;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class EchoServer { public static void main(String []args) throws Exception{ ServerSocket server = new ServerSocket(9999); Socket client = server.accept(); // 连接客户端 // 得到客户端输入数据以及向客户端输出数据的对象 Scanner scan = new Scanner(client.getInputStream()); PrintStream out = new PrintStream(client.getOutputStream()); boolean flag = true; while(flag){ if(scan.hasNext()){ String str = scan.next().trim(); // 得到客户端发送的内容 if(str.equalsIgnoreCase(\"byebye\")){ // 程序要结束 out.println(\"拜拜，下次再会！\"); flag = false; }else{ // 回应该输入信息 out.println(\"ECHO : \" + str); } } } scan.close(); out.close(); server.close(); client.close(); }} 示例：实现客户端代码 1234567891011121314151617181920212223242526272829303132import java.io.PrintStream;import java.net.Socket;import java.util.Scanner;public class EchoClient { public static void main(String[] args) throws Exception{ Socket client = new Socket(\"localhost\",9999); Scanner input = new Scanner(System.in); // 从键盘输入 Scanner scan = new Scanner(client.getInputStream()); input.useDelimiter(\"\\n\"); scan.useDelimiter(\"\\n\"); PrintStream out = new PrintStream(client.getOutputStream()); boolean flag = true; while(flag){ System.out.print(\"请输入要发送的数据：\"); if(input.hasNext()){ String str = input.next().trim(); out.println(str); // 发送服务器端数据 if(str.equalsIgnoreCase(\"byebye\")){ flag = false; // 结束循环 } if(scan.hasNext()){ System.out.println(scan.next()); // 输出回应数据 } } } input.close(); scan.close(); out.close(); client.close(); }} 此时就实现了一个最简单的服务器端与客户端通讯。此时的程序只能够连接一个客户端，而不能连接其他客户端，因为所有操作都是在主线程上进行的开发，也就是说此时的程序属于单线程的网络应用，实际中不可能如此进行，为了能够让一个服务器端可以同时处理多个客户端的操作，我们使用多线程描述，把每一个连接到服务器的客户都作为一个独立的线程保留。 示例：修改服务器端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.IOException;import java.io.PrintStream;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;class EchoThread implements Runnable{ private Socket client; public EchoThread(Socket client) { this.client = client; } @Override public void run() { try { // 得到客户端输入数据以及向客户端输出数据的对象 Scanner scan = new Scanner(client.getInputStream()); PrintStream out = new PrintStream(client.getOutputStream()); boolean flag = true; while(flag){ if(scan.hasNext()){ String str = scan.next().trim(); // 得到客户端发送的内容 if(str.equalsIgnoreCase(\"byebye\")){ // 程序要结束 out.println(\"拜拜，下次再会！\"); flag = false; }else{ // 回应该输入信息 out.println(\"ECHO : \" + str); } } } scan.close(); out.close(); client.close(); } catch (IOException e) { e.printStackTrace(); } }}public class EchoServer { public static void main(String []args) throws Exception{ ServerSocket server = new ServerSocket(9999); boolean flag = true; while(flag){ Socket client = server.accept(); // 连接客户端 new Thread(new EchoThread(client)).start(); } server.close(); }} 服务器开发的基础要素：网络支持类、IO、多线程。","link":"/2018/10/24/Java_55_网络编程/"},{"title":"Chapter 54 IO 高级应用","text":"讲解了缓冲输入流、扫描流和对象序列化的\b基本概念与操作 IO 高级应用1. 缓冲输入流【重点】缓冲输入流是在开发中大量使用到的工具类，其目的是解决数据的乱码问题。现在最直观的就是解决 System.in 输入的问题。 要处理中文字符，首先想到字符流，要想处理完整的数据，那么一ID那个要到缓冲区，对于缓冲区的操作，有两种流： 字符缓冲区流：BufferedReader【重点】,BufferedWriter； 字节缓冲区流：BufferedInputStream,BufferedOutputStream。 给出了两个缓冲区输入流中，BufferedReader 很重要，它有一个重要的读取方法：public String readLine() throws IOException ，读取一行数据，以分隔符（换行）为界。 观察 BufferedReader 的继承结构和构造方法： 继承结构 123java.lang.Object |- java.io.Reader |- java.io.BufferedReader 构造方法public BufferedReader(Reader in) 有构造方法可以看出，想使用 BufferedReader 类来处理 System.in 的操作比较麻烦，因为 System.in 是 InputStream 类。之前学习的类 InputStreamReader 类（Reader 的子类，接收 InputStream）示例：键盘输入的标准格式 123456789101112131415package com.company;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class TestDemo { public static void main(String[] agrs) throws IOException { // System.in 是 InputStream 类 // BufferedReader 的构造方法中需要接收 Reader 类对象 // 利用 InputStreamReader 将字节流变为字符流 BufferedReader buf = new BufferedReader(new InputStreamReader(System.in)); System.out.print(\"请输入数据：\"); String str = buf.readLine(); // 以回车作为换行 System.out.print(\"输入的内容：\" + str); }} 此时输入数据没有长度限制，并且得到的是 String 类。这种操作意义不大，作为知识点讲解。 一直强调 BufferedReader 可以实现字符串数据的接收，那么可以基于正则进行判断。示例：判断输入内容 123456789101112131415161718192021222324package com.company;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class TestDemo { public static void main(String[] agrs) throws IOException { // System.in 是 InputStream 类 // BufferedReader 的构造方法中需要接收 Reader 类对象 // 利用 InputStreamReader 将字节流变为字符流 BufferedReader buf = new BufferedReader(new InputStreamReader(System.in)); boolean flag = true; while(flag){ System.out.print(\"请输入年龄：\"); String str = buf.readLine(); // 以回车作为换行 if(str.matches(\"\\\\d{1,3}\")){ System.out.print(\"输入的年龄：\" + Integer.parseInt(str)); flag = false; } else{ System.out.println(\"年龄输入错误，年龄应该由数字组成，请重新输入！\"); } } }} 因为此处可以进行正则验证，那么开发中如果接收 String 类是最方便的。 除了可以接收输入信息外，缓冲区读取还可以进行文件的读取。示例：缓冲区进行文件读取 1234567891011121314package com.company;import java.io.*;public class TestDemo { public static void main(String[] agrs) throws IOException { File file = new File(\".\"+File.separator+\"testA.txt\"); BufferedReader buf = new BufferedReader(new FileReader(file)); String str = null; while((str = buf.readLine()) != null){ System.out.println(str); } buf.close(); }} 与直接使用 InputStream、Reader 类相比，使用BufferedReader 在进行文件读取时更方便。 2. 扫描流 Scanner如果要改进输出功能不足有打印流，随后利用 BufferedReader 解决了大文本\b数据的读取操作，但是BufferedReader 类有两个缺点： 它读取数据的时候只能按照字符串返回：public String readLine() throws IOException 所有的分隔符都是固定的（换行）。 JDK 1.5 之后 提供了 java.util.Scanner 类，这个类专门负责解决所有输入流的操作问题。 构造方法：public Scanner(InputStream source)接收有一个 InputStream 类对象，表示的是由外部设置输入的位置。 在 Scanner 中定义了两大组方法： 判断是否有指定数据：public boolean hasNextXxx(); 取出指定数据：public 数据类型 nextXxx(); 示例：Scanner 解决键盘输入 1234567891011121314package com.company;import java.io.*;import java.util.Scanner;public class TestDemo { public static void main(String[] agrs) throws IOException { Scanner scan = new Scanner(System.in); // 准备接受键盘输入数据 System.out.print(\"请输入数据：\"); if(scan.hasNext()){ // 现在有输入数据 System.out.println(\"输入内容：\" + scan.next()); } scan.close(); }} Scanner 类与 BufferedReader 类相比，Scanner 更加容易，操作更加简便。需要提醒的是：如果输入的是 String 类型，是否存在 hasNext() 区别不大，但如果是其他数据类型 hasNextXxx() 就有作用，为了保持操作的统一性，建议都加上 hasNext() 判断。 范例：输入一个数字—double 1234567891011121314151617package com.company;import java.io.*;import java.util.Scanner;public class TestDemo { public static void main(String[] agrs) throws IOException { Scanner scan = new Scanner(System.in); // 准备接受键盘输入数据 System.out.print(\"请输入成绩：\"); if(scan.hasNextDouble()){ // 表示输入的是一个小数 double score = scan.nextDouble(); // 省略了转型 System.out.println(\"输入的成绩：\" + score); }else{ // 表示输入的不是一个小数 System.out.println(\"输入的不是数字，错误！\"); } scan.close(); }} 除了以上支持的各种类型外，Scanner 也可以在输入的时候设置正则验证 示例：正则验证 1234567891011121314151617package com.company;import java.io.*;import java.util.Scanner;public class TestDemo { public static void main(String[] agrs) throws IOException { Scanner scan = new Scanner(System.in); // 准备接受键盘输入数据 System.out.print(\"请输入生日：\"); if(scan.hasNext(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\")){ String bir = scan.next(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\"); // 可以不设置，这里为了保持统一 System.out.println(\"输入的生日：\" + bir); }else{ System.out.println(\"输入的生日格式错误！\"); } scan.close(); }} 在 Scanner 类的构造方法中接收的是 InputStream 类，所以可以设置文件的输入流，在文件读取时要考虑分隔符问题。 【重点】：设置分隔符方法：public Scanner useDelimiter(String pattern) 示例：Scanner 读取文件 123456789101112131415package com.company;import java.io.*;import java.util.Scanner;public class TestDemo { public static void main(String[] agrs) throws IOException { Scanner scan = new Scanner(new FileInputStream(\".\" + File.separator + \"testA.txt\")); // 设置分隔符为换行符，如果不设置的话 默认 空格和换行符都是分隔符 scan.useDelimiter(\"\\n\"); while(scan.hasNext()){ System.out.println(scan.next()); } scan.close(); }} 在以后的开发之中，程序输出数据采用打印流（PrintStream），输入数据使用 Scanner（如果发现 \bScanner 不好用了，那么使用 BufferedReader）。\bInputStream 类的功能不足已经被 Scanner 解决了；Reader 类的功能不足已经被 BufferedReader 解决了；OutputStream 类的功能不足已经被 PrintStream 解决了；Writer 类的功能不足已经被 PrintWriter 解决了。 3. 对象序列化【重点】对象序列化指的就是将保存在内存中的对象数据转换为二进制数据流进行传输的操作。并不是所有的类对象都可以被序列化，需要实现 java.io.Serializable 接口。这个接口中并没有任何操作方法存在，因为它是一个标识接口，表示一种能力。 我们见到了两个标识接口： Cloneable 接口，\b对象的克隆 Serializable 接口：用于对象的序列化 3.1 定义一个可被序列化对象的类示例：定义一个可以被序列化对象的类 1234567891011121314151617181920package com.company;import java.io.*;class Book implements Serializable{ private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } @Override public String toString() { return \"书名：\" + this.title +\"、价格为：\" + this.price; }}public class TestDemo { public static void main(String[] agrs) throws IOException { }} 这个类的对象可以进行二进制传输了。 【注意】：我使用的是 JDK 1.8，Book 类定义是没有黄线，不需要修改。若出现黄线，查看提示后可能是需要增加 私有属性序列化 ID，或者在类前面增加语句@SuppressWarnings(&quot;serial&quot;) 压制警告。 3.2 实现序列化与反序列化【了解】现在仅有单机程序，所以下面将对象序列化到文件里面，再通过文件反序列化到程序中。要想实现这样的操作，我们需要以下两个类的支持： 序列化类：java.io.ObjectOutputStream，将对象变成了指定格式的二进制数据 构造方法：public ObjectOutputStream(OutputStream out)throws IOException 输出对象：public final void writeObject(Object obj)throws IOException 反序列化类：java.io.ObjectInputStream，将序列化的对象\b转回对象内容 构造方法：public ObjectInputStream(InputStream out)throws IOException 输出对象：public final Object readObject(Object obj)throws IOException \b范例：实现序列化对象操作 123456public static void ser() throws IOException{ ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(\".\" + File.separator + \"book.ser\")); oos.writeObject(new Book(\"Java 开发\",79.8)); // 序列化对象 oos.close();} 在主程序中调用 ser() 方法即可。 读取二进制信息只能使用反序列化。示例：实现反序列化操作，ObjectInputStream 12345678public static void dser() throws Exception{ ObjectInputStream ois = new ObjectInputStream( new FileInputStream(new File(\".\" + File.separator + \"book.ser\"))); Object obj = ois.readObject(); // 按照 Object 读取 Book book = (Book)obj; System.out.println(book); ois.close();} 在主程序中调用 dser() 方法。 在以后的实际开发中，会由容器帮助用户实现以上的操作 3.3 transient 关键字（理解）以上虽然实现了对象序列化，但是会发现序列化操作时是将对象的属性内容进行了保存，如果某些属性的内容不需要保存，就可以通过 transient 关键字来定义。 private transient String title; // 那么反序列化输出为：书名：null、价格为：79.8 此时 title 属性将无法被序列化。大部分情况下都不需要使用此关键字。 3.4 总结对象序列化本身是一个\b很简单的概念，但是由于其在开发中应用非常广泛，所以编写代码中要清楚 Serialiazable 接口的作用。需要注意的是：不是所有的类都需要被序列化，只有需要传输的对象所在的类才要进行序列化操作。","link":"/2018/10/24/Java_54_IO高级应用/"},{"title":"Linux中安装MySQL","text":"检查是否已经安装过Mysql rpm -qa | grep mysql 卸载已经安装的Mysql rpm -e -nodeps mysql-libs 检查/tmp文件夹的权限，cd /，ll，如果没有-表示所有用户都有读写权限，否则 chomd 777 /tmp 安装客户端 和 服务端 查看mysql的安装位置 ps -ef | grep mysql 解决中文字符乱码问题，修改字符集 查看字符集 show variables like 'character%'; show variables like '%char%'; 默认的服务器（character_set_server）用了latin1，拉丁字符集，不支持中文 修改my-huge.cnf 在 /usr/ share/ mysql 中找到 my-huge.cnf 的配置文件，拷贝其中的 my-huge.cnf 到 /etc/ 并命名为my.cnf，然后修改 my.cnf，增加以下内容： [client] default-character-set=utf8 [mysqld] character_set_server=utf8 character_set_client=utf8 collation-server = utf8_general_ci [mysql] default-character-set = utf8 重启mysql 查看原库的字符集 show create database mydb 原库的设定不会发生变化，参数修改只对新建的数据库生效 已生成的库表字符集变更 修改数据库的字符集 mysql&gt; alter database $数据库名$ character set 'utf-8'; 修改数据表的字符集 mysql&gt; alter table $表名$ convert to character set 'utf-8'; 对user表的修改，必须通过flush privileges; 命令才能生效 MySQL的sql_mode设置，默认为空值，这种设置允许一些非法操作，例如非法数据的插入。在生产环境中必须将这个值设置为严格模式，所以开发、测试环境的数据库也必须要设置，这样就可以在开发测试阶段发现问题。 show variabiles like 'sql_model'; set sql_mode='ONLY_FULL_GROUP_BY'; 可以有多种设置 Mysql 索引结构：BTree索引、 B+Tree索引 B树和B+树的区别： 1)B树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息;B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。 2)在B树中，越靠近根节点的记录査找时间越快，只要找到关键字即可确定记录的存在;而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B树的性能好像要比B+树好，而在实际应用中却是B+树的能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B树多，树高比B树小，这样带来的好处是减少磁盘访间次数。尽管B+树找到一个记录所需的比较次数要比B村多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历(例如查看一个目录下的所有文件，一个表中的所有记录等)这也是很多数据库和文件系统使用B+树的缘故。 思考:为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引? 1)B+树的磁盘读写代价更低，B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 2)B+树的查询效率更加稳定由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 索引需要创建索引的情况 主键自动建立唯一索引 频繁作为查询条件的字段应该创建索引 查询中与其它表关联的字段,外键关系建立索引 单键/组合索引的选择问题，组合索引性价比更高 査询中排序的字段,排序字段若通过索引去访问将大大提高排序速度 查询中统计或者分组字段 不要创建索引 表记录太少 经常增删改的表或者字段（索引提高查询速度的同时降低了更新的速度，需要保存数据和索引文件） where 条件里用不到的字段 过滤性不好的不适合建索引","link":"/2019/10/28/Linux安装MySQL/"},{"title":"Chapter 56 类集框架","text":"类集就是 Java 数据结构的实现，类集就是动态对象数组。 类集框架类集就是 Java 数据结构的实现，类集就是动态对象数组；类集里面有以下几个核心接口： Collection、List、Set Map Iterator，Enumeration 1. Collection 接口（重点）Collection 是整个类集中单值保存的最大父接口。每一次可以向集合中宝存一个对象。 方法【重点】 为 Iterator 接口实例化开发之中：add() 方法和 iterator() \b两个方法使用几率是最高的。 开发中很少\b直接使用 Collection 接口了，会使用它的两个子接口：List（允许重复）、Set（不允许重复）。 2. List 子接口最常用的子接口，功能扩展： List 本身属于接口，想要使用的话用其子类 ArrayList（90%，或者用 Vector） 示例：List 基本操作 1234567891011121314151617181920package com.company;import java.util.ArrayList;import java.util.List;public class TestDemo { public static void main(String[] args){ // 设置了泛型，从而保证集合中所有的数据类型都一样 List&lt;String&gt; all = new ArrayList&lt;String&gt;(); System.out.println(\"长度：\" + all.size() + \"、是否为空：\" + all.isEmpty()); all.add(\"Hello\"); all.add(\"Hello\"); // 重复元素 all.add(\"World\"); System.out.println(\"长度：\" + all.size() + \"、是否为空：\" + all.isEmpty()); // Collection 接口定义了 size() 方法可以取得集合长度 // List 子类扩充了 get() 方法可以根据索引取得对象 for(int i = 0; i &lt; all.size(); i++){ String str = all.get(i); // 取得索引数据 System.out.println(str); } }} List 集合保存的顺序是按照保存的顺序存放，\b允许重复，注意 List 子接口扩充有 get() 方法 示例：在集合中保存对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.company;import java.util.ArrayList;import java.util.List;class Book{ private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } @Override public boolean equals(Object obj) { if(obj == null){ return false; } if(obj == this){ return true; } if(!(obj instanceof Book)){ return false; } Book book = (Book)obj; if(this.title.equals(book.title) &amp;&amp; this.price == book.price){ return true; } return false; } @Override public String toString() { return \"书名：\" + this.title + \"、价格为：\" + this.price + \"\\n\"; }}public class TestDemo { public static void main(String[] args){ List&lt;Book&gt; all = new ArrayList&lt;Book&gt;(); all.add(new Book(\"Java开发\",79.8)); all.add(new Book(\"JSP开发\",69.8)); all.add(new Book(\"Oracle开发\",89.8)); // 任何情况下集合数据的删除和内容的查询都必须提供 equals() 方法 all.remove(new Book(\"JSP开发\",69.8)); System.out.println(all); }} 任何情况下集合数据的删除和内容的查询都必须提供 equals() 方法 Vector 是旧的类，Vector 与 ArrayList 的区别： 推出时间：ArrayList 是 JDK1.2 之后出来的，Vector 是从 JDK1.0 之后开始使用 性能：ArrayList 采用异步处理，Vector 采用同步处理 数据安全：ArrayList 是非线程安全的，Vector 是线程安全的 输出：ArrayList\b 支持 Iterator、ListIterator、foreach，Vector 除了支持以上三个外还支持 Enumeration 总结： List 中的数据保存顺序就是数据添加的顺序 List 集合中可以有重复的元素 List 子接口比 Collection 扩充了 get() 方法 List 选择子类就使用 ArrayList 接口。 3. Set 接口Collection 的另一个常用子接口（20%）。Set 接口只是简单地继承了 Collection 接口，并没有大量的扩充，因此没有 List 中的 get() 方法。 Set 接口下有两个常用子类：HashSet、TreeSet HashSet: 集合没有重复元素（Set 接口\b的特征），\b集合是无序的，HashSet 子类的特征是无序排列。 TreeSet ：没有重复数据，保存的内容自动排序 集合是一个动态的对象数组，想为一组对象进行排序，在 Java 中必须使用比较器必须实现 Comparable 接口。 TreeSet 特点 TreeSet 是根据 Comparable 接口中的 compareTo() 方法来判断数据是否重复，如果返回 0 ，就认为是重复数据，不会被保存。因此在 覆写 compareTo() 时全部属性都要参与比较。12345678910111213141516171819202122232425262728293031323334353637package com.company;import java.util.Set;import java.util.TreeSet;class Book implements Comparable&lt;Book&gt;{ private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } @Override public String toString() { return \"书名：\" + this.title + \"、价格为：\" + this.price + \"\\n\"; } @Override public int compareTo(Book o) { if(this.price &gt; o.price){ return 1; }else if(this.price &lt; o.price){ return -1; }else{ // 调用 String 类的 compareTo() 方法 return this.title.compareTo(o.title); } }}public class TestDemo { public static void main(String[] args){ Set&lt;Book&gt; all = new TreeSet&lt;Book&gt;(); all.add(new Book(\"Java开发\",79.8)); all.add(new Book(\"JSP开发\",69.8)); all.add(new Book(\"Oracle开发\",79.8)); System.out.println(all); }} compareTo() 可以使 TreeSet 中没有重复，但是换成 HashSet 就不能判断重复了。 4. 关于重复元素的说明Comparable 接口只能负责 TreeSet 子类\b进行重复元素的判断（在排序时进行判断，HashSet 不进行排序因此无法判断），它并不是用于重复元素验证的操作。 如果想判断重复元素只能依靠 Object 类中提供的方法： 取得哈希码： public int hashCode()先判断对象的 哈希码是否相同，依靠哈希码取得一个对象的内容； 对象比较：public boolean equals(Object obj)再将对象的属性依次进行比较 示例：\b利用编译器自动生成 hashCode() 和 \bequals() 方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.company;import java.util.HashSet;import java.util.Set;import java.util.TreeSet;class Book{ private String title; private double price; public Book(String title, double price) { this.title = title; this.price = price; } @Override public String toString() { return \"书名：\" + this.title + \"、价格为：\" + this.price + \"\\n\"; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Book book = (Book) o; if (Double.compare(book.price, price) != 0) return false; return title != null ? title.equals(book.title) : book.title == null; } @Override public int hashCode() { int result; long temp; result = title != null ? title.hashCode() : 0; temp = Double.doubleToLongBits(price); result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32)); return result; }}public class TestDemo { public static void main(String[] args){ Set&lt;Book&gt; all = new HashSet&lt;Book&gt;(); all.add(new Book(\"Java开发\",79.8)); all.add(new Book(\"JSP开发\",69.8)); all.add(new Book(\"Oracle开发\",79.8)); all.add(new Book(\"Oracle开发\",79.8)); System.out.println(all); }} 以后在非排序的情况下，只要是判断重复元素依靠的永远是 hashcode() 和 equals() 方法。 Set 总结 在开发中，Set 接口绝不是首选，如果真的要使用也建议使用 HashSet 子类 Comparable 这种比较器只会存在在 Java 的理论范畴中，例如要进行 TreeSet Set 不管如何操作，必须保证一个前提：数据不能够重复 5. 集合输出五种方法：\b\bIterator（95%），ListIterator（0.05%），Enumeration（5%），foreach（0.05%） 迭代输出 Iterator 接口【重点】1234public interface Iterator&lt;E&gt;{ public boolean hasNext(); public E next();} 之前见到的 Scanner 类是 Iterator 的子类 Iterator 是一个接口，如果想要取得本接口实例化只能依靠 Collection 接口，Collection 接口中有一个方法：public Iterator &lt;E&gt; iterator(); 123456789101112131415161718package com.company;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class TestDemo { public static void main(String[] args){ Set&lt;String&gt; all = new HashSet&lt;String&gt;(); all.add(\"Hello\"); all.add(\"world\"); all.add(\"world\"); Iterator&lt;String&gt; iterator = all.iterator(); while(iterator.hasNext()){ String str = iterator.next(); System.out.println(str); } }} 双向迭代：ListIterator（了解）Iterator 只能由前向后输出，ListIterator 可以实现由前向后输出，由后向前输出。 有两个核心方法： 判断是否有前一个元素：\bpublic boolean hasPrevious(); 取得前一个元素：public E previous() ListIterator 是专门为 List 子接口定义的输出接口，方法：public ListIterator&lt;E&gt; listIterator() 范例：完成双向迭代 12345678910111213141516171819202122package com.company;import java.util.*;public class TestDemo { public static void main(String[] args){ List&lt;String&gt; all = new ArrayList&lt;String&gt;(); all.add(\"A\"); all.add(\"B\"); all.add(\"C\"); ListIterator&lt;String&gt; iter = all.listIterator(); System.out.print(\"由前向后输出：\"); while(iter.hasNext()){ String str = iter.next(); System.out.print(str+\"、\"); } System.out.print(\"\\n由后向前输出：\"); while(iter.hasPrevious()){ String str = iter.previous(); System.out.print(str+\"、\"); } }} 如果想要由后向前输出，必须先要由前向后输出。 foreach 操作1234567891011121314package com.company;import java.util.*;public class TestDemo { public static void main(String[] args){ List&lt;String&gt; all = new ArrayList&lt;String&gt;(); all.add(\"A\"); all.add(\"B\"); all.add(\"C\"); for(String str:all){ System.out.println(str); } }} foreach 不建议使用，初学阶段建议使用 Iterator Enumeration 输出12public boolean hasMoreElements(); // 判断是否有下一个元素，等同于 hasNext()public E nextElement(); // 取出当前元素，相当于 next() 如果想要使用 Enumeration 接口的实例化对象只能依靠 Vector 子类，Vector 中定义有如下方法： 取得 Enumeration 接口对象：public Enumeration&lt;E&gt; elements()12345678910111213141516package com.company;import java.util.*;public class TestDemo { public static void main(String[] args){ Vector&lt;String&gt; all = new Vector&lt;String&gt;(); all.add(\"A\"); all.add(\"B\"); all.add(\"C\"); Enumeration&lt;String&gt; enumeration = all.elements(); while(enumeration.hasMoreElements()){ String str = enumeration.nextElement(); System.out.println(str); } }} 在一些古老的操作中会使用到，所以还是要掌握。 6. Map 接口保存\b一对关联数据（key = value），Map 接口提供根据 key 值查找对应 value的操作。 123456789101112package com.company;import java.util.*;public class TestDemo { public static void main(String[] args){ Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(\"一\",1); map.put(\"二\",2); map.put(\"三\",3); map.put(\"三\",33); System.out.println(map); }} 示例：Map 进行查询操作 1234567891011121314151617181920package com.company;import java.util.*;public class TestDemo { public static void main(String[] args){ Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(\"一\",1); map.put(\"二\",2); map.put(\"三\",3); map.put(null,33); System.out.println(map); // 输出 1 System.out.println(map.get(\"一\")); // 输出 null System.out.println(map.get(\"六\")); // 输出 33 System.out.println(map.get(null)); }} 通过以上代码可以看出：Map 存放数据的目的是为了信息的查找，Collection 存放数据是为了输出。 Hashtable 里面对 key 和 value 的数据都不允许设置为 null。 【问题】HashMap（90%） 与 Hashtable（10%） 的区别 推出时间：HashMap 是 JDK1.2 之后出来的，Hashtable 是从 JDK1.0 之后开始使用 性能：HashMap 采用异步处理，Hashtable 采用同步处理 数据安全：HashMap 是非线程安全的，Hashtable 是线程安全的 设置 null ：HashMap 允许 key 或 value 值为 null；Hashtable 不允许设置 null 【重点】 Map 关于 Iterator \b接口的输出 【重点】示例：利用 Iterator 实现 Map\b 接口的输出 123456789101112131415161718package com.company;import java.util.*;public class TestDemo { public static void main(String[] args){ Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(\"一\",1); map.put(\"二\",2); map.put(\"三\",3); // 将 Map 集合变为 Set 集合，目的是为了使用 iterator() 方法 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = map.entrySet(); Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iter = set.iterator(); while(iter.hasNext()){ Map.Entry&lt;String,Integer&gt; me = iter.next(); System.out.println(me.getKey() + \" = \" + me.getValue()); } }} 关于 Map 集合中 key 的说明： 在定义 Map 时首选的 key 是 String 类型，尽量不要使用自定义的类型。 7. Stack 子类Stack 表示的是栈操作，是一种先进后出的结构。是 Vector 子类，不使用 Vector 的方法，使用自己的方法： 12345678910111213141516171819package com.company;import java.util.*;public class TestDemo { public static void main(String[] args){ Stack&lt;String&gt; s = new Stack&lt;String&gt;(); s.push(\"A\"); s.push(\"B\"); s.push(\"C\"); // 输出 C System.out.println(s.pop()); // 输出 B System.out.println(s.pop()); // 输出 A System.out.println(s.pop()); // 异常 EmptyStackException System.out.println(s.pop()); }} 在进行栈操作的过程中，如果栈中没有数据了，那么无法继续出栈 8. Properties 类Properties 类\b是 Hashtable 的子类，主要是进行属性的操作（属性的最大特点是利用字符串设置 key 和 value） 在 Properties 类里面提供有数据的输出操作：public void store(OutputStream out,String comment)，comment 表示注释\b示例：设置属性、取得属性、将属性保存在文件里 123456789101112131415161718192021222324252627282930313233343536package com.company;import java.io.File;import java.io.FileOutputStream;import java.util.*;public class TestDemo { public static void main(String[] args) throws Exception { Properties pro = new Properties(); pro.setProperty(\"BJ\",\"北京\"); pro.setProperty(\"TJ\",\"天津\"); // 输出 ：北京 System.out.println(pro.getProperty(\"BJ\")); // 输出 null System.out.println(pro.getProperty(\"GZ\")); // 输出默认值：没有此记录 System.out.println(pro.getProperty(\"GZ\",\"没有此记录\")); // 一般而言文件后缀可以随便设置，但是标准来讲，既然是属性文件，h后缀必须是\"*.properties\"，这样做也是为了与国际化对应 pro.store(new FileOutputStream(new File(\".\" + File.separator + \"area.properties\")),\"Area Info\"); }}``` ![](Image_Java_56_类集框架/2018-10-25-20-28-52.png)```javapackage com.company;import java.io.File;import java.io.FileInputStream;import java.util.*;public class TestDemo { public static void main(String[] args) throws Exception { Properties pro = new Properties(); pro.load(new FileInputStream(new File(\".\" + File.separator + \"area.properties\"))); System.out.println(pro.getProperty(\"BJ\")); }} 对于属性文件，可以用 Properties 类读取，还可以使用 resourceBoundle 类读取，这是为什么要将后缀设置为 *.properties 的原因。 9. Collections工具类集合的工具类：为集合追加数据，集合反转 12345678910111213package com.company;import java.util.*;public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new ArrayList&lt;String&gt;(); // 为集合追加数据 Collections.addAll(all,\"A\",\"B\",\"C\",\"D\"); // 集合反转 Collections.reverse(all); System.out.println(all); }} 9. 数据流：Stream 类除了使用 Iterator 迭代取出数据并且处理，JDK1.8 之中提供了一个专门进行数据处理的类 Stream。这个类可以利用 Collection 接口提供的方法操作：default Stream&lt;E&gt; stream() 示例：取得 Stream 类对象 12345678910111213141516package com.company;import java.util.*;import java.util.stream.Stream;public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new ArrayList&lt;String&gt;(); all.add(\"Hello\"); all.add(\"world\"); all.add(\"good\"); // 取得 Stream 类对象 Stream&lt;String&gt; stream = all.stream(); // 取得数据个数 System.out.println(stream.count()); }} 下面进行数据加工操作范例 Stream 类中提供一个消除重复的方法：public Stream distinct()1234567891011121314151617181920212223package com.company;import java.util.*;import java.util.stream.Collectors;import java.util.stream.Stream;public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new ArrayList&lt;String&gt;(); all.add(\"Hello\"); all.add(\"world\"); all.add(\"good\"); all.add(\"Hello\"); all.add(\"world\"); all.add(\"good\"); // 取得 Stream 类对象 Stream&lt;String&gt; stream = all.stream(); // 取得非重复数据个数 //System.out.println(stream.distinct().count()); // 去掉重复数据形成的新集合， Stream 流只能打开一次 List&lt;String&gt; newAll = stream.distinct().collect(Collectors.toList()); newAll.forEach(System.out :: println); }} 数据过滤： 123456789101112131415161718192021222324package com.company;import java.util.*;import java.util.stream.Collectors;import java.util.stream.Stream;public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new ArrayList&lt;String&gt;(); all.add(\"Java\"); all.add(\"Android\"); all.add(\"Ios\"); all.add(\"jsp\"); all.add(\"ORACLE\"); // 取得 Stream 类对象 Stream&lt;String&gt; stream = all.stream(); // 取得非重复数据个数 //System.out.println(stream.distinct().count()); // 去掉重复数据形成的新集合， Stream 流只能打开一次 // 增加了数据过滤操作，使用了断言型的函数接口，使用了 String 类中的 contains() 方法 List&lt;String&gt; newAll = stream.distinct().filter((x) -&gt; x.contains(\"a\")).collect(Collectors.toList()); newAll.forEach(System.out :: println); }} 1List&lt;String&gt; newAll = stream.distinct().map((x) -&gt; x.toLowerCase()).filter((x) -&gt; x.contains(\"a\")).collect(Collectors.toList()); 12// 跳过两个，取两个数据List&lt;String&gt; newAll = stream.distinct().map((x) -&gt; x.toLowerCase()).skip(2).limit(2).collect(Collectors.toList()); 1234567891011121314151617181920package com.company;import java.util.*;import java.util.stream.Stream;public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new ArrayList&lt;String&gt;(); all.add(\"Java\"); all.add(\"Android\"); all.add(\"Ios\"); all.add(\"jsp\"); all.add(\"ORACLE\"); // 取得 Stream 类对象 Stream&lt;String&gt; stream = all.stream(); if(stream.anyMatch((x) -&gt; x.contains(\"jsp\"))){ System.out.println(\"数据存在\"); } }} 现在只判断了一个条件 \b示例：设置多个条件 1234567891011121314151617181920212223package com.company;import java.util.*;import java.util.function.Predicate;import java.util.stream.Stream;public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new ArrayList&lt;String&gt;(); all.add(\"Java\"); all.add(\"Android\"); all.add(\"Ios\"); all.add(\"jsp\"); all.add(\"ORACLE\"); Predicate&lt;String&gt; p1 = (x) -&gt; x.contains(\"jsp\"); Predicate&lt;String&gt; p2 = (x) -&gt; x.contains(\"Ios\"); // 取得 Stream 类对象 Stream&lt;String&gt; stream = all.stream(); // p1.and(p2) 匹配的是字符串 \"jspIos\"这种类型的，查找一个字符串 if(stream.anyMatch(p1.or(p2))){ System.out.println(\"数据存在\"); } }} 1234567891011121314151617181920212223class ShopCar{ private String pnaem; private double price; // 商品单价 private int amount; // 商品数量 public ShopCar(String pnaem, double price, int amount) { this.pnaem = pnaem; this.price = price; this.amount = amount; } public String getPnaem() { return pnaem; } public double getPrice() { return price; } public int getAmount() { return amount; }} 想要计算商品的花费，需要用 单价数量*示例**：进行数据的保存与初步的处理 12345678910111213141516171819202122232425262728293031323334353637package com.company;import java.util.*;class ShopCar{ private String pnaem; private double price; // 商品单价 private int amount; // 商品数量 public ShopCar(String pnaem, double price, int amount) { this.pnaem = pnaem; this.price = price; this.amount = amount; } public String getPnaem() { return pnaem; } public double getPrice() { return price; } public int getAmount() { return amount; }}public class TestDemo { public static void main(String[] args) throws Exception { List&lt;ShopCar&gt; all = new ArrayList&lt;ShopCar&gt;(); all.add(new ShopCar(\"A\",20.0,20)); all.add(new ShopCar(\"B\",18.0,30)); all.add(new ShopCar(\"C\",36.0,40)); all.add(new ShopCar(\"D\",99.0,50)); all.add(new ShopCar(\"E\",200.0,60)); double sumAll = all.stream().map((x) -&gt; x.getAmount()*x.getPrice()).reduce((sum,m) -&gt; sum + m).get(); System.out.println(\"花费：\"+sumAll); }} 1234567891011121314151617public class TestDemo { public static void main(String[] args) throws Exception { List&lt;ShopCar&gt; all = new ArrayList&lt;ShopCar&gt;(); all.add(new ShopCar(\"A\",20.0,20)); all.add(new ShopCar(\"B\",18.0,30)); all.add(new ShopCar(\"C\",36.0,40)); all.add(new ShopCar(\"D\",99.0,50)); all.add(new ShopCar(\"E\",200.0,60)); DoubleSummaryStatistics dss = all.stream().mapToDouble((sc) -&gt; sc.getAmount()*sc.getPrice()) .summaryStatistics(); System.out.println(\"商品的总数：\" + dss.getCount()); System.out.println(\"商品的平均花费：\" + dss.getAverage()); System.out.println(\"商品的总花费\" + dss.getSum()); System.out.println(\"商品的最大花费\" + dss.getMax()); System.out.println(\"商品的最小花费\" + dss.getMin()); }} MapReduce：Map 处理数据Reduce 分析数据","link":"/2018/11/05/Java_56_类集框架/"},{"title":"Linux笔记","text":"Linux 系统中一切皆文件。 Linux 目录结构介绍 /bin：是Binary的缩写，这个目录存放着最经常使用的命令 /home：存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 /root：该目录为系统管理员，也称作超级权限者的用户主目录 /lib：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库 /etc：所有的系统管理所需要的配置文件和子目录 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录 /boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里 /tmp：这个目录是用来存放一些临时文件的 /dev：类似于windows的设备管理器，把所有的硬件用文件的形式存储 /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下 /opt：这是给主机额外安装软件所摆放的目录。例如安装一个ORACLE数据库则就可以放到这个目录下。默认是空的 /usr/local：这是另一个给主机额外安装软件所摆放的目录。一般是通过编译源码方式安装的程序 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件 vi/vim 编辑器常用命令按下i,a,o,R等字母进入编辑模式，进入后左下角会有[insert]或[replace]的字样，按下[ESC]即可退出编辑模式。 按键 效果 i，I 当前光标前，当前光标所在行最前 a，A 当前光标后，光标所在行最后 o，O 当前光标的下一行，当前光标上一行 s，S s：删除当前字符并进入编辑S：删除整行并进入编辑 R 进入替换模式 要在一般模式下输入/或 : 可进入命令模式，进入后鼠标移至最下端： 命令 含义 :w 保存 :q 推出 :! 强制执行 :%s/被替换的字符/新字符 批量替换 /要查找的词 回车后，n 查找下一个，N查找上一个 ?要查找的词 回车后，n 查找上一个，N查找下一个 :set nu / :set nonu 显示行号/关闭行号 一般模式：以vi打开一个文件就能直接进入一般模式即默认模式 语法 功能描述 yy 复制光标当前一行 y数字y 复制一段（从第几行到第几行） p 箭头移动到目的行粘贴 u 撤销上一步 dd 删除光标当前行 d数字d 删除光标（含）后多少行 x 删除一个字母，相当于del，向后删 X 删除一个字母，相当于Backspace，向前删 yw 复制一个词 dw 删除一个词 shift+^ 移动到行头 shift+$ 移动到行尾 gg或者1+G 移动到页头 G 移动到页尾 数字+G（先输入数字，在按G） 移动到目标行","link":"/2019/10/24/Linux命令/"},{"title":"Chapter 50 字节流与字符流","text":"File 类虽然可以操作文件，但是并不能操作文件的内容，\b要进行内容的操作有两种方法：字节流、字符流。 字节流与字符流1. 简介File 类虽然可以操作文件，但是并不能操作文件的内容，\b要进行内容的操作有两种方法：字节流、字符流。\b进行输入、输出操作一般会按照如下的步骤（以文件操作为例）： 通过 File 类定义一个要操作文件的路径 通过字节流或字符流的子类对象为父类对象实例化 进行\b数据的读（输入）、写（输出）操作； 数据流属于资源操作，资源操作必须关闭。 java.io 包定义了两类流： 字节流（JDK1.0）：InputStream、OutputStream 字符流（JDK1.1）：Reader，Writer 2. \b字节输出流：OutputStream（重点）OutputStream 类是一个专门进行字节数据输出的类，这个类的定义如下： 1public abstract class OutputStream extends Object implements Closeable,Flushable 这两个接口定义如下：Closeable 接口: JDK1.5 提供 定义方法，接口继承： 123public interface Closeable extends AutoCloseable{ public void close() throws IOException;} JDK 1.7 之后引入了自动关闭机制，Closeable 又多继承了 AutoCloseable 接口。 Flushable 接口: JDK 1.5 定义方法：123public interface Flushable{ public void flush() throws IOException;} 但是 OutputStream 类是在 JDK1.0 就提供了，其中包括 close() 和 flush() 方法，因此以上接口可以忽略。 在 OutputStream 中提供了三个输出的方法： \b输出单个字节：public abstract void write(int b) throws IOException；因为 int 类型用的比较广泛，并且可以实现： byte a = 120;，所以参数类型设置为 \bint，但要记住：传入的是 byte 型。 输出全部字节数组：public abstract void write(byte[] b)throws IOException 【重要】输出部分字节数组：public abstract void write(byte[] b,int off,int len) throws IOException，其中 off 表示开始位置，len 表示长度。 OutputStream 为抽象类，如果要想为抽象类实例化对象，要使用抽象类的子类，文件操作可以使用 FileOutputStream。这个子类有如下定义： 【常用】创建或覆盖已有文件：public FileOutputStream(File file) throws FileNotFoundException 文件内容追加：public FileOutputStream(File file,boolean append)throws FileNotFoundException 示例：实现文件内容的输出，使用字节数组如果此时要输出的文件不存在，会自动创建。 1234567891011121314151617181920212223package com.company;import java.io.File;import java.io.FileOutputStream;import java.io.OutputStream;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 // 1. 定义要输出文件的路径 File file = new File(\".\" + File.separator + \"test.txt\"); // 1. 判断目录是否存在，目录不存在则创建目录 if(!file.getParentFile().exists()){ file.getParentFile().mkdirs(); // 创建目录 } // 2. 应该使用OutputStream和其子类进行对象的实例化，此时目录存在，文件还不存在。 OutputStream output = new FileOutputStream(file); // 3. 要进行文件内容的输出 String str = \"好好学习，天天向上！\"; byte data[] = str.getBytes(); // 将字符串变为字节数组 output.write(data); // 将内容输出 // 4. 资源操作的最后一定要关闭 output.close(); }} 示例：使用单个字节的方式输出： 123for(int i = 0; i &lt; data.length; i++){ output.write(data[i]); // 将内容输出} 示例：输出部分字节内容注意：一个中文占三个字节。 1output.write(data,6,6); // 将内容输出: 学习 实现内容的追加，替换 FileOutputStream 类的构造方法即可。注意：如果要实现换行，在\b字符串中添加 \\r\\n。 1234// 2. 应该使用OutputStream和其子类进行对象的实例化，此时目录存在，文件还不存在。OutputStream output = new FileOutputStream(file,true);// 3. 要进行文件内容的输出String str = \"好好学习，天天向上！\\r\\n\"; 3. 字节输入流 InputStream 类如果程序要实现数据读取的操作，可以使用 InputStream 类，此类虽然也实现了 Closeable 接口，但也不用考虑。有三种数据读取的方法： 读取单个字节：public abstract int read()throws IOException|- 返回值：返回读取的字节内容，如果现在没有内容。 将读取的数据保存在字节数组里：public int read(byte[] b)throws IOException|- 返回值：返回读取的数据长度，如果已经读取到结尾，返回 -1. 将读取的数据保存在部分字节数组里：public int read(byte[] b,int off,int len)throws IOException|- 返回值：返回读取的部分数据长度，如果已经读取到结尾，返回 -1. 同样，InputStream 是一个抽象类，文件读取可以使用 FileInputStream 类，构造方法：public FileInputStream(File file) throws FileNotFoundException示例：向数组里面读取数据 123456789101112131415161718192021package com.company;import java.io.File;import java.io.FileInputStream;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 // 1. 定义要输入文件的路径 File file = new File(\".\" + File.separator + \"test.txt\"); // 1. 判断文件存在才可以继续读取 if(file.exists()) { // 文件存在 // 2. 使用 InputStream 读取 FileInputStream input = new FileInputStream(file); // 3. 进行数据读取 byte data[] = new byte[1024]; // 准备一个 1024 的数组 int len = input.read(data); // 将内容保存到字节数组中,len 接收读取长度 // 4. 关闭输入流 input.close(); System.out.println(\"【\"+new String(data,0,len)+\"】\"); } }} 示例：单个字节数据读取 由于一个文件中有很多字节数据，读取应该采用循环的方法，因为不知道\b数据长度，所以应该采用 while() 循环，为了更好的演示问题，使用 while() 和 do…while() 两种方法。 使用 do…while() 一般是不用的。 12345678910111213141516171819202122232425262728package com.company;import java.io.File;import java.io.FileInputStream;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 // 1. 定义要输入文件的路径 File file = new File(\".\" + File.separator + \"test.txt\"); // 1. 判断文件存在才可以继续读取 if(file.exists()) { // 文件存在 // 2. 使用 InputStream 读取 FileInputStream input = new FileInputStream(file); // 3. 进行数据读取 byte data[] = new byte[1024]; // 准备一个 1024 的数组 int foot = 0; // 表示字节数组的操作角标 int temp = 0; // 表示接收每次读取的字节数组 do{ temp = input.read(); // 读取一个字节 if(temp != -1) { // 现在是真实的内容 data[foot++] = (byte)temp; // 保存读取的字节到数组中 } }while(temp!=-1); // 现在读取的temp不是 -1，表示还有内容 // 4. 关闭输入流 input.close(); System.out.println(\"【\"+new String(data,0,foot)+\"】\"); } }} 【重点】使用 while()，此类方式是在开发中经常使用的。与上一个代码效果相同，简单很多。 12345678910111213141516171819202122232425262728package com.company;import java.io.File;import java.io.FileInputStream;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 // 1. 定义要输入文件的路径 File file = new File(\".\" + File.separator + \"test.txt\"); // 1. 判断文件存在才可以继续读取 if(file.exists()) { // 文件存在 // 2. 使用 InputStream 读取 FileInputStream input = new FileInputStream(file); // 3. 进行数据读取 byte data[] = new byte[1024]; // 准备一个 1024 的数组 int foot = 0; // 表示字节数组的操作角标 int temp = 0; // 表示接收每次读取的字节数组 // 第一部分：temp =input.read() 将 read() 方法读取的字节内容给了 temp // 第二部分：(temp =input.read()) != -1，判断读取出来的 temp 内容是否为 -1 while((temp =input.read()) != -1){ data[foot++] = (byte)temp; // 有内容就进行保存 } // 4. 关闭输入流 input.close(); System.out.println(\"【\"+new String(data,0,foot)+\"】\"); } }} 4. 字符输出流：WriterWriter 是在 JDK1.1 之后增加的，其类的定义中除了实现了 Closeable、Flushable 接口外，还实现了 Appendable 接口。 123456public interface Appendable{ public Appendable append(char c)throws IOException; // CharSequence 相当于字符串 public Appendable append(CharSequence csq)throws IOException; public Appendable append(CharSequence csq,int start,int end)throws IOException; } 在 Appendable 接口中定义了追加的操作，而且追加的数据都是字符或者字符串。在 Writer类中定义了如下的输出方法（部分）： 输出全部字符数组：public void write(char[] cbuf)throws IOException 输出字符串：public void write(String str) throws IOExceptionWriter 是一个抽象类，想为这个类的对象实例化，使用 FileWriter，FileWriter有两个构造方法，参数同 FileOutputStream。12345678910111213141516171819202122package com.company;import java.io.File;import java.io.FileWriter;import java.io.Writer;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 // 1. 定义要输入文件的路径 File file = new File(\".\" + File.separator + \"test.txt\"); // 1. 判断目录是否存在，目录不存在则创建目录 if(!file.getParentFile().exists()){ file.getParentFile().mkdirs(); // 创建目录 } // 2. 应该使用Writer和其子类进行对象的实例化，此时目录存在，文件还不存在。 Writer out = new FileWriter(file); // 3. 要进行文件内容的输出 String str = \"努力学习 Java，Come on！\"; out.write(str); // 输出字符串数据 // 4. 资源操作的最后一定要关闭 out.close(); }} 可以看出，Writer 可以进行字符串数据的输入，比 OutputStream 强。 5. 字符输入流：ReaderReader 是进行字符数据读取的输入流，其本身也是一个抽象类：public abstract class Reader extends Object implements Readable,Closeable在 Reader 类里面也提供一系列的 read() 方法： 读取内容到字符数组：public int read(char[] cbuf)throws IOException|- 返回值：表示读取的数据长度，如果已经读取到结尾了返回 -1；为 Reader 类实例化的可以使用 FileReader 子类完成。 注意：不提供读取字符串的方法是因为文件过大程序会崩溃，Writer 能够输出一定是程序允许的数据量。 为 Reader 类对象实例化可以使用 FileReader示例：使用 Reader 读取数据 12345678910111213141516171819202122package com.company;import java.io.File;import java.io.FileReader;import java.io.Reader;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 // 1. 定义要输入文件的路径 File file = new File(\".\" + File.separator + \"test.txt\"); // 1. 判断文件存在才可以继续读取 if(file.exists()){ // 2. 应该使用 Reader 和其子类进行对象的实例化 Reader in = new FileReader(file); // 3. 进行数据读取 char data[] = new char[1024]; int len = in.read(data); // 4. 资源操作的最后一定要关闭 in.close(); System.out.println(new String(data,0,len)); } }} 与字节输入流几乎一样，只不过返回数据由 byte 变成了 char。 6. 字节流与字符流的区别最大区别：字节流直接与终端进行数据交互，字符流需要将数据经过缓冲区处理后才可以输出。使用字节流 OutputStream 输出数据的时候即使没有关闭输出流，内容也可以正常输出；但是如果使用字符流 Writer，没有关闭输出流的话就表明在缓冲区的数据不会被强制性的清空，因此不会输出数据。如果有特殊情况不能关闭输出流，那么可以舒勇 flush() 强制清空缓冲区。示例：使用 flush() 强制清空缓冲区 1234567891011121314151617package com.company;import java.io.File;import java.io.FileWriter;import java.io.Writer;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 File file = new File(\".\" + File.separator + \"test.txt\"); if(!file.getParentFile().exists()){ file.getParentFile().mkdirs(); // 创建目录 } Writer out = new FileWriter(file); String str = \"努力学习 Java，Come on！\"; out.write(str); // 输出字符串数据 out.flush(); // 强制清空缓冲区 }} 注意：中文处理强烈建议字符流；如果没有中文，建议使用字节流。 7. 转换流（了解）字节流与字符流的转换。在 java.io 包中提供了两个类：InputStreamReader、OutputStreamWriter InputStreamReader： 定义：public class InputStreamReader extends Reader 构造方法：public InputStreamReader(InputStream in)InputStreamReader 是 Reader 的子类，构造方法中将 InputStream 转换为 InputStreamReader。 OutputStreamWriter： 定义：public class OutputStreamWriter extends Reader 构造方法：public OutputStreamWriter(OutputStream out)OutputStreamWriter 是 Writer 的子类，构造方法中将 OutputStream 转换为 OutputStreamWriter。12345678910111213141516171819package com.company;import java.io.*;public class TestDemo { public static void main(String[] agrs) throws Exception { // 处理异常 File file = new File(\".\" + File.separator + \"test.txt\"); if(!file.getParentFile().exists()){ file.getParentFile().mkdirs(); // 创建目录 } OutputStream output = new FileOutputStream(file); // 字节流 // 将OutputStream对象传递给OutputStreamWriter类的构造方法，而后向上转型为 Writer Writer out = new OutputStreamWriter(output); String str = \"努力学习 Java，Come on！！！\"; out.write(str); // 输出字符串数据 out.flush(); // 强制清空缓冲区 // 或者 out.close(); }} 转换的意义不大，只有一种情况下会用这样的转换：方便处理中文。 【观察】观察类的继承结构FileInputStream 类的继承结构： 123java.lang.Object |- java.io.InputStream |- java.io.FileInputStream FileOutputStream 类的继承结构 123java.lang.Object |- java.io.OutputStream |- java.io.FileOutputStream FileInputStream 和 FileOutputStream 都是 InputStream 和 OutputStream 的直接子类。 FileReader 类的继承结构： 1234java.lang.Object |- java.io.Reader |- java.io.InputStreamReader |- java.io.FileReader FileWriter 类的继承结构： 1234java.lang.Object |- java.io.Writer |- java.io.OutputStreamWriter |- java.io.FileWriter FileWriter 和 FileReader 的父类存在转换类：OutputStreamWriter、InputStreamReader。这是因为：文件都存在与磁盘上，磁盘上的文件都是以字节的方式保存的，在使用字符流读取的时候实际上是针对字节数据进行读取，但这个转换过程被操作系统隐藏了，\b在缓冲区里面进行了数据的操作 【总结】 如果要进行转换唯一的形式就是处理中文 两个转化类都是字符流的子类，属于字符流与字节流沟通的桥梁。 8. 综合实战：文件拷贝模拟 DOS 系统的文件拷贝程序，实现字节流的综合使用。 实现文件拷贝有两种方法 一次性读入程序中，而后一次性输出。（针对大文件不可能实现） 采用\b边读变输出的方式，不会占用过大的内存空间。 有可能要拷贝二进制数据，因此字节流比较合适。 示例：基本实现 1234567891011121314151617181920212223242526272829303132333435363738package com.company;import java.io.*;public class CopyDemo { public static void main(String[] args) throws Exception{ long start = System.currentTimeMillis(); // 1. 判断参数个数 if(args.length != 2){ System.out.println(\"参数不符合规范\"); System.exit(1); } // 2. 判断源文件是否存在 File inFile = new File(args[0]); if(!inFile.exists()){ System.out.println(\"请检查源文件是否存在\"); System.exit(1); } // 3. 判断目标路径是否存在，不存在则创建 File outFile = new File(args[1]); if(!outFile.getParentFile().exists()){ outFile.getParentFile().mkdirs(); } // 4. 实现文件内容拷贝 OutputStream output = new FileOutputStream(outFile); InputStream input = new FileInputStream(inFile); // 5. 实现文件的拷贝 int temp = 0; while((temp = input.read())!= -1){ // 每次读取单个字节 output.write(temp); // 输出单个字节 } // 6. 关闭资源文件 input.close(); output.close(); long end = System.currentTimeMillis(); System.out.println(\"拷贝耗费时长：\"+ (end-start)); }} 单字节拷贝：实现了拷贝，但是拷贝速度很慢 回顾字节流的两个操作方法： InputStream：将读取的数据保存在字节数组里：public int read(byte[] b)throws IOException|- 返回值：返回读取的数据长度，如果已经读取到结尾，返回 -1. OutputStream：public abstract void write(byte[] b,int off,int len) throws IOException，其中 off 表示开始位置，len 表示长度。|- 要设置的字节数组实际上就是在 read() 方法里面使用的数组|- 一定是从字节数组的第 0 个元素开始，输出读取的数组长度 1234567// 5. 实现文件的拷贝byte data[] = new byte[1024];int temp = 0; // 保存每次读取的个数//将每次读取进来的数据保存在字节数组里，并返回读取的个数while((temp = input.read(data))!= -1){ output.write(data,0,temp); // 输出单个字节} 以上的代码 100% 会使用到，给出 InputStream 后就按照上面的方式实现功能。注意的是 data 数组的大小会影响输出时间\b，在一定程度上越大时间越短，但是太大了时间提升的空间小。因此使用 1024 或 2048 是好的选择。","link":"/2018/10/24/Java_50_字节流与字符流/"},{"title":"Linux 常用命令","text":"一些经常使用到的 Linux 命令。文件的移动复制等。 Linux 常用命令1. 复制文件 cp 源文件地址/* 目标文件夹：将源文件地址下的所有文件（只能拷贝文件）复制到目标文件夹【文件】 如果源文件夹下有文件夹，那么使用 -r 递归拷贝 cp -r 源文件夹 目标文件夹：将\b源文件夹复制到目标文件夹【文件夹】 cp -r 源文件夹/* 目标文件夹 或者 cp -r 源文件夹/ 目标文件夹：将原文件夹下的文件复制到目标文件夹【文件】 2. 重命名和移动文件 重命名：mv A B， 将A命名为B（若该文件夹下有B，会被覆盖） 移动文件：mv /a /b/c ，将 a 文件夹移动 b 文件夹下并命名为 c 3. 远程传递文件 【注意】：scp 传递文件 scp -r 传递文件夹 将文件传到服务器上：【在客户端执行】scp -r local_dir username@servername:remote_dir 【举例】scp -r software fujiaojiao@111.204.219.209:~/fujiaojiao/把当前目录下的 software 目录上传到服务器账号为 fujiaojiao 地址为111.204.219.209 的文件夹 ~/fujiaojiao/ 下。 将文件服务器下载：【在客户端执行】scp -r username@servername:remote_dir local_dir 【举例】scp -r fujiaojiao@111.204.219.209:~/fujiaojiao/ ./将账号为 fujiaojiao 地址为111.204.219.209 的服务器\b， ~/fujiaojiao 下的内容拷贝到 当前文件夹下（ ./ ） 断点续传rsync -P --rsh=ssh /tmp/test.tar 192.168.1.190:/home/test.tar rsync -P --rsh=ssh /tmp/test.tar root@192.168.1.190:/home/test.tar 4. 根据文件名批量删除文件 find ./ -type f -name &quot;*.log&quot; |xargs rm -rf，将当前目录下文件名后缀为 “.log” 的文件删除。 ./：代表当前目录 -type f ：代表查找文件，d代表查找目录 -name： 匹配文件名， &quot;*.log&quot;：以.log结尾的文件 |xargs：执行某个命令 rm -rf：删除操作 5. 查看文本文件的命令：cat 用法：cat [选项] [文件]…，将[文件]或标准输入组合输出到标准输出。 -A, –show-all 等价于 -vET -b, –number-nonblank 对非空输出行编号 -E, –show-ends 在每行结束处显示 $ -n, –number 对输出的所有行编号 -s, –squeeze-blank 不输出多行空行 -e 等价于 -vE -t 与 -vT 等价 -T, –show-tabs 将跳格字符显示为 ^I -v, –show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 【举例】： cat text.txt ：将整个文件显示到屏幕上 cat text.txt &gt; test.txt ：将 text.txt 的内容定向到 test.txt 文件 cat text.txt &gt;&gt; test.txt ：将 text.txt 的内容追加到 test.txt 文件 cat -s text.txt ：将多个连续空白行显示成一行 cat -n text.txt ：输出 text.txt 时显示行号 cat -b text.txt ：只在非空白行前显示行号 6. 解压与压缩命令tar 参数选项[操作][其他][-f] 档案名称 第一个参数选项： -c： 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。 中间参数选项： -z：有 gzip 属性的 -j：有 bz2 属性的 -Z：有 compress 属性的 -v：显示所有过程 -O：将文件解开到标准输出 最后一个参数【必选参数】 -f -f： 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 【示例】 压缩 tar –cvf jpg.tar *.jpg ：将目录里所有 jpg 文件打包成 tar.jpg tar –czf jpg.tar.gz *.jpg ：将目录里所有 jpg 文件打包成 jpg.tar后，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，命名为 jpg.tar.gz tar –cjf jpg.tar.bz2 *.jpg ：将目录里所有 jpg 文件打包成 jpg.tar后，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，命名为 jpg.tar.bz2 tar –cZf jpg.tar.Z *.jpg ：将目录里所有 jpg 文件打包成 jpg.tar后，并且将其用 compress 压缩，生成一个 umcompress 压缩过的包，命名为 jpg.tar.Z 解压 tar –xvf file.tar ：解压 file.tar 包 tar -xzvf file.tar.gz ：解压 file.tar.gz tar -xjvf file.tar.bz2 ：解压 file.tar.bz2 tar –xZvf file.tar.Z ：解压 file.tar.Z 总结 *.tar ： tar –xvf 解压 *.gz ： gzip -d或gunzip 解压 *.tar.gz： *.tgz 或 tar –xzf 解压 *.bz2 ： bzip2 -d或bunzip2 解压 *.tar.bz2 ： tar –xjf 解压 *.Z ： uncompress 解压 *.tar.Z ：tar –xZf 解压 7. ubuntu 下 vi 模式的改变 vi：在编辑模式下使用方向键的时候，并不会使光标移动，而是在命令行中出现[A [B [C [D 之类的字母，而且编辑错误的话，就连平时关于的退格键(Backspace键)都使用不了，只能用Delete来删除。 编辑 /etc/vim/vimrc.tiny 【root 权限下】 将 set compatible 中的 compatible 改成 nocompatible：非兼容模式就可以解决方向键变 ABCD 的问题了。 set backspace=2 ：解决Backspace键的问题 。","link":"/2018/11/05/Linux常用命令/"},{"title":"Spring笔记","text":"优良特性 依赖注入（DI-Depenfency Injection），反转控制的最经典表现 面向切面编程 AOP-Aspect Oriented Programming 一站式，在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 名词解释 IOC-Inversion of Control 反转控制 传统：应用程序的组件获取资源时，组件主动从容器中获取所需要的资源，因此需要知道在特定容器如何创建资源对象 反转控制的思想：反转资源的获取方向，容器主动的将资源推给需要的组建，因此不需要知道如何创建资源对象，只需要提供接收资源的方式 DI-Dependency Inject 依赖注入 IOC的另一种表述方式，组件以一些预先定义好的方式(例如setter方法)接收来自容器的注入。IOC是一种思想，DI是IOC思想的具体实现。 注解标识组件 普通组件 @Component：标识一个受Spring IOC容器管理的普通组件 持久化层组件 @Repository 业务逻辑层组件：@Service 表示层控制器组件：@Controller Spring没有能力标识一个组件是不是它标记的类型，将@Service注解用在一个表示层控制器组件也不会出错，所以@Repository、@Service、@Controller仅仅是为了让开发人员明确当前组件的角色。 ###组件装配 @Autowired 注解 @Resource 注解 @Inject 注解","link":"/2019/10/21/Spring笔记/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/13/hello-world/"},{"title":"Chapter 57 类集框架","text":"Java 数据库编程，JDBC（Java Database Connective），Java 数据库连接技术。Java 提供的一组与平台无关的数据库的操作标准，是一组接口的组成。数据库属于资源操作，所以所有的数据库操作的最后必须要关闭数据库连接。 Java 数据库编程（JDBC）1. 介绍所有的服务都是固定的流程，属于应用。 JDBC（Java Database Connective），Java 数据库连接技术。Java 提供的一组与平台无关的数据库的操作标准，是一组接口的组成。 数据库属于资源操作，所以所有的\b数据库操作的最后必须要关闭数据库连接。 四种 Java 数据库的操作方式： 形式一：JDBC-ODBC 桥接技术（100%不用） 形式二：JDBC 直接连接，性能最好，但是支持的 JDBC 版本有限 直接由不同的数据库生产商提供指定的数据库连接驱动程序（实现了 Java 的数据库操作标准的一群类） 形式三：JDBC 网络连接 使用专门的数据库的网络连接指令进行指定主机的数据库操作。 形式四：模拟制定数据库的通讯协议自己编写数据库操作 2. 连接 mysql 数据库一、介绍在 Java 之中，所有数据库操作的类和接口都保存在 java.sql 包 一个类：DriverManager 类； 四个接口：Connection、Statement、ResultSet、PreparedStatement。 所有的 JDBC 连接数据库的操作流程都是固定的，按照如下的几步完成： \b加载数据库的驱动程序（向容器加载）； 进行数据库连接（通过 DriverManager 类完成，Connection 表示连接）； 进行数据的 CRUD（Statement、PreparedStatement，ResultSet）； 关闭数据库操作以及连接（直接关闭连接就可以） mysql 程序驱动类：com.mysql.jdbc.Driver。 加载类使用：Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 二、连接数据库如果想要连接数据库需要提供如下的几个信息（前提：数据库服务要打开）： 数据库的连接地址：jdbc:mysql:主机名称:端口名称:数据库的SID 连接本机的 test 数据库：jdbc:mysql://localhost:3306/test 数据库的用户名：root 数据库的密码：admin 要连接数据库必须依靠 DriverManager 类完成\b，在此类定义有如下方法： 连接数据库：public static Connection getConnection(String url,String user,String password) throws Exception 在 JDBC 里面，每一个数据库连接都要求使用一个 Connection 对象进行封装，所以只要有一个新的\b Connection 就表示要连接一次数据库。 四、关闭数据库Connection 接口\b提供有 close() 方法：public void close() throws SQLException 示例：mysql 数据的连接 123456789101112131415161718192021222324package com.company;import java.sql.Connection;import java.sql.DriverManager;public class TestDemo { // JDBC 驱动名及数据库 URL static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost:3306/test\"; // 数据库的用户名与密码，需要根据自己的设置 static final String USER = \"root\"; static final String PASS = \"admin\"; public static void main(String[] args) throws Exception { // 第一步：加载数据库驱动程序，此时不需要实例化，会有容器自己负责管理 Class.forName(JDBC_DRIVER); // 第二步：连接数据库 Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); // 输出不为空则证明连接成功 com.mysql.jdbc.JDBC4Connection@1de0aca6 System.out.println(conn); // 第四步： 关闭数据库 conn.close(); }} 在 JDBC 操作中，\b在驱动数据库连接对象时，采用的是工厂设计模式，而DriverManagement 就是一个工厂类，那么我们客户端调用的时候会完全隐藏具体的实现子类。 总结： 以后不管连接何种关系型数据库，都一定要通过 DriverManager 进行数据库连接； 每一个 Connection 接口对象就表示一个数据库连接，程序的最后必须关闭数据连接。 3. Statement接口mysql 数据库密码：admin 创建表： 12345678CREATE TABLE IF NOT EXISTS member( mid INT NOT NULL AUTO_INCREMENT, name VARCHAR(20), birthday DATE, age INT, note VARCHAR(100), PRIMARY KEY(mid))DEFAULT CHARSET=utf8; 数据的更新操作最关键性的问题是每次更新完成之后都一定回返回影响的数据行数： 范例：数据增加 INSERT INTO 表名称 (列,列,…) VALUES(值,值,…); 范例：数据更新 UPDATE 表名称 SET 字段=值，… WHERE 更新条件(s); 范例：数据删除 DELETE FROM 表名称 WHERE 删除条件(s); 插入、更新、删除： 12345INSERT INTO member(name,birthday,age,note) VALUES(&quot;张三&quot;,&apos;1998-08-16&apos;,20,&quot;一个人&quot;)UPDATE member SET name=&apos;李四&apos;,birthday=NOW(),age=0 WHERE mid IN(8,9,10)DELETE FROM member WHERE mid IN(1,5) 插入中文数据要注意：在数据库 URL 后面添加?characterEncoding=UTF-8否则中文会出现乱码。 示例：插入一条数据 1234567891011121314151617181920212223242526272829303132package com.company;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class TestDemo { // JDBC 驱动名及数据库 URL static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8\"; // 数据库的用户名与密码，需要根据自己的设置 static final String USER = \"root\"; static final String PASS = \"admin\"; public static void main(String[] args) throws Exception { // 第一步：加载数据库驱动程序，此时不需要实例化，会有容器自己负责管理 Class.forName(JDBC_DRIVER); // 第二步：连接数据库 Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); // 第三步：进行数据库的数据操作 Statement stmt = conn.createStatement(); // 在编写 SQL 语句时，太长了需要换行时，请一定要在前后加上空格 String sql = \" INSERT INTO member(name,birthday,age,note) VALUES \" + \" ('张三','1998-08-16',20,'一个人') \"; int len = stmt.executeUpdate(sql); // 执行SQL 返回更新的数据行 System.out.println(\"影响的数据行：\" + len); // 第四步： 关闭数据库 stmt.close(); // 是可选的 无用的 conn.close(); }} 在 ResultSet 接口里面定义了如下的方法： 向下移动指针并判断是否有数据行：public boolean next() throws SQLException 移动之后就可以直接取得当前数据行中所有数据列的内容了 取出数据列的内容：getInt()、getDouble()、getString()、getDate()。 范例：实现数据的查询查询时不要写 SELECT *，写出查询的具体内容。 12345678910String sql = \"SELECT mid,name,age,birthday,note FROM member\"; ResultSet rs = stmt.executeQuery(sql); while(rs.next()){ // 循环取出返回的每一行数据 int mid = rs.getInt(\"mid\"); String name = rs.getString(\"name\"); int age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); String note = rs.getString(\"note\"); System.out.println(mid + \",\" + name + \",\" + age + \",\" + birthday + \",\" + note); } 关于 ResultSet 的使用有以下几点忠告： 在使用 getXxx() 取出列数据的时候，强烈建议按照给定的顺序取； 在每一个列的数据只能够按照顺序取一次； 以上的代码在 SQL 语句中给出了列名称了，那么可以按照序号取出。 12345678910String sql = \"SELECT mid,name,age,birthday,note FROM member\"; ResultSet rs = stmt.executeQuery(sql); while(rs.next()){ // 循环取出返回的每一行数据 int mid = rs.getInt(1); String name = rs.getString(2); int age = rs.getInt(3); Date birthday = rs.getDate(4); String note = rs.getString(5); System.out.println(mid + \",\" + name + \",\" + age + \",\" + birthday + \",\" + note); } 4. PreparedStatement接口Statement 如果想要变为灵活的应用，那么就必须采用拼凑字符串的方式完成，可是如果输入的内容有 '，那么整个 SQL 就会出错，也就是说\b Statement 的执行模式不适合于处理一些敏感字符。 Statement 执行关键性的问题是在与它需要一个完整的字符串来定义要使用的 SQL 语句，所以这就导致在使用中需要大量的进行 SQL 的拼凑，而 PreparedStatement 与 Statement 不同的地方在与，它执行的是一个完整的具备特殊占位标记的 SQL 语句，并且可以动态的设置所需要的数据。 想要取得 PreparedStatement 这个子接口的实例化对象，依然需要使用 Connection 接口提供的方法：public PreparedStatement prepareStatement(String sql) throws SQLException，里面在执行的时候需要一个 SQL 语句，这个 SQL 一个具备特殊标记的完整 SQL，此时没有内容，当取得了 PreparedStatement 接口对象，需要使用一系列的 setXxx() 方法用于为使用的标记设置具体内容，而后对于执行操作有两个方法支持： 更新操作：public int executeUpdate() throws SQLException; 查询操作：public ResultSet executeQuery() throws SQLException 当使用了 PreparedStatement 接口操作时需要注意的是里面的 setDate() 方法，使用的是 java.sql.date 不再是 java.util.Date。 在 java.util.Date 类下有三个子类都是在 java.sql 包中的： java.sql.Date：描述的是日期； java.sql.Time：描述的是时间； java.sql.TimeStamp：描述的是时间戳（日期时间） 如果要\b将 java.util.Date 变为 java.sql.Date（Time、Timestamp）只能依靠 long 型： java.util.Date：public long getTime()，可以将 Date 变为 long； java.sql.Date：public Date(long date)，将 long 变为 sql.Date sql.Date 可以向上转型为 util.Date，例如：Date birthday = rs.getDate(3); 示例：使用 PreparedStatement 123456789101112131415161718192021222324252627public static void main(String[] args) throws Exception { String name = \"Mr'Smith\"; int age = 30; Date birthday = new Date(); System.out.println(birthday); String note= \"外国人\"; // 第一步：加载数据库驱动程序，此时不需要实例化，会有容器自己负责管理 Class.forName(JDBC_DRIVER); // 第二步：连接数据库 Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); // 第三步：进行数据库的数据操作 // 在编写 SQL 语句时，太长了需要换行时，请一定要在前后加上空格 String sql = \" INSERT INTO member(name,birthday,age,note) VALUES (?,?,?,?)\"; PreparedStatement stmt = conn.prepareStatement(sql); stmt.setString(1,name); stmt.setDate(2,new java.sql.Date(birthday.getTime())); stmt.setInt(3,age); stmt.setString(4,note); int len = stmt.executeUpdate(); System.out.println(\"影响的行数：\"+len); // 第四步： 关闭数据库 stmt.close(); // 是可选的 无用的 conn.close(); } 示例：查询操作 12345678910111213141516171819202122public static void main(String[] args) throws Exception { // 第一步：加载数据库驱动程序，此时不需要实例化，会有容器自己负责管理 Class.forName(JDBC_DRIVER); // 第二步：连接数据库 Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); // 第三步：进行数据库的数据操作 // 在编写 SQL 语句时，太长了需要换行时，请一定要在前后加上空格 String sql = \"SELECT mid,name,birthday,age,note FROM member ORDER BY mid\"; PreparedStatement stmt = conn.prepareStatement(sql); ResultSet rs = stmt.executeQuery(); while(rs.next()){ int mid = rs.getInt(1); String name = rs.getString(2); Date birthday = rs.getDate(3); int age = rs.getInt(4); String note = rs.getString(5); System.out.println(mid + \",\" + name + \",\" + birthday + \",\" + age + \",\" + note); } // 第四步： 关闭数据库 stmt.close(); // 是可选的 无用的 conn.close(); } 示例：模糊查询操作，设定关键词 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception { String keywords = \"李\"; // 第一步：加载数据库驱动程序，此时不需要实例化，会有容器自己负责管理 Class.forName(JDBC_DRIVER); // 第二步：连接数据库 Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); // 第三步：进行数据库的数据操作 // 在编写 SQL 语句时，太长了需要换行时，请一定要在前后加上空格 String sql = \"SELECT mid,name,birthday,age,note FROM member WHERE name LIKE ?\"; PreparedStatement stmt = conn.prepareStatement(sql); stmt.setString(1,\"%\" + keywords + \"%\"); ResultSet rs = stmt.executeQuery(); while(rs.next()){ int mid = rs.getInt(1); String name = rs.getString(2); Date birthday = rs.getDate(3); int age = rs.getInt(4); String note = rs.getString(5); System.out.println(mid + \",\" + name + \",\" + birthday + \",\" + age + \",\" + note); } // 第四步： 关闭数据库 stmt.close(); // 是可选的 无用的 conn.close(); } 如果 keyword = &quot;&quot;;那么匹配全部内容，与直接查询的不同：直接查询不需要判断，直接返回数据。设置条件的查询速度很慢。 示例：分页显示 12345678910111213141516171819// 在编写 SQL 语句时，太长了需要换行时，请一定要在前后加上空格// LIMIT 第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。String sql = \"SELECT * FROM (\" + \" SELECT mid,name,birthday,age,note FROM member \" + \" WHERE name LIKE ?)\" + \" as total LIMIT ?,?\";PreparedStatement stmt = conn.prepareStatement(sql);stmt.setString(1,\"%\" + keywords + \"%\");stmt.setInt(2, 1);stmt.setInt(3, 2);ResultSet rs = stmt.executeQuery();while(rs.next()){ int mid = rs.getInt(1); String name = rs.getString(2); Date birthday = rs.getDate(3); int age = rs.getInt(4); String note = rs.getString(5); System.out.println(mid + \",\" + name + \",\" + birthday + \",\" + age + \",\" + note);} 示例：统计数据量，使用 COUNT() 函数 123456789101112131415161718192021public static void main(String[] args) throws Exception { String keywords = \"李\"; // 第一步：加载数据库驱动程序，此时不需要实例化，会有容器自己负责管理 Class.forName(JDBC_DRIVER); // 第二步：连接数据库 Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); // 第三步：进行数据库的数据操作 String sql = \"SELECT COUNT(mid) FROM member WHERE name LIKE ?\"; PreparedStatement stmt = conn.prepareStatement(sql); stmt.setString(1,\"%\" + keywords + \"%\"); ResultSet rs = stmt.executeQuery(); while(rs.next()){ // 只返回一行数据 int count = rs.getInt(1); // 取出第一列 System.out.println(count); } // 第四步： 关闭数据库 stmt.close(); // 是可选的 无用的 conn.close(); } 开发中不会使用 Statement 只会使用 PreparedStatement 接口。 4. 批处理操作所谓的批处理指的是一次性向数据库之中发出多条操作命令，一起执行。如果想要操作批处理，还是需要在 Statement 与 PreparedStatement 接口上定义的： Statement 接口定义的方法： 增加批处理语句：public void addBatch(String sql) throws SQLException 执行批处理：public int executeBatch() throws SQLException，返回的数组是包含了所有批处理语句的执行结果； PreparedStatement 接口定义的方法： 增加批处理：public void addBatch() throws SQLException 示例：\bStatement 执行批处理 123456789101112131415161718192021222324252627282930package com.company;import java.sql.*;import java.util.Arrays;public class TestDemo { // JDBC 驱动名及数据库 URL static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8\"; // 数据库的用户名与密码，需要根据自己的设置 static final String USER = \"root\"; static final String PASS = \"admin\"; public static void main(String[] args) throws Exception { Class.forName(JDBC_DRIVER); Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); Statement stmt = conn.createStatement(); stmt.addBatch(\"INSERT INTO member(name) VALUES ('测试A')\"); stmt.addBatch(\"INSERT INTO member(name) VALUES ('测试B')\"); stmt.addBatch(\"INSERT INTO member(name) VALUES ('测试C')\"); stmt.addBatch(\"INSERT INTO member(name) VALUES ('测试D')\"); stmt.addBatch(\"INSERT INTO member(name) VALUES ('测试E')\"); stmt.addBatch(\"INSERT INTO member(name) VALUES ('测试F')\"); int result[] = stmt.executeBatch(); // 执行批处理 // 输出：[1, 1, 1, 1, 1, 1] System.out.println(Arrays.toString(result)); conn.close(); }} 示例：PreparedStatement 批处理操作 1234567891011121314151617181920public static void main(String[] args) throws Exception { Class.forName(JDBC_DRIVER); Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); String sql = \"INSERT INTO member(name) VALUES (?)\"; PreparedStatement stmt = conn.prepareStatement(sql); // 设置 SQL 语句 stmt.setString(1,\"测试AA\"); // 将一组参数添加到此 PreparedStatement 对象的批处理命令中 stmt.addBatch(); stmt.setString(1,\"测试BB\"); stmt.addBatch(); stmt.setString(1,\"测试CC\"); stmt.addBatch(); stmt.setString(1,\"测试DD\"); stmt.addBatch(); int result[] = stmt.executeBatch(); // 执行批处理 // 输出：[1, 1, 1, 1] System.out.println(Arrays.toString(result)); conn.close(); } 如果假设以上的五条批处理属于一组关联的操作，如果中间有一条语句执行失败，其他的不应该成功。在批处理操作的过程之中，由于 JDBC 具备有自动的事物提交，所以一旦中间的语句出现了错误，那么结果就是错误的。错误前的语句可以正常执行，错误后的语句无法正常执行，\b\b这是不应该的。 可以使用 JDBC 提供的事务处理操作来进行手工的事物控制，所有的操作方法都在 Connection 接口里定义： 事物提交：public void commit() throws SQLException 事物回滚：public void rollback() throws SQLException 设置是否为自动提交：publiv void setAutoCommit(boolean autoCommit) throws SQLException 示例：利用事务处理 123456789101112131415161718public static void main(String[] args) throws Exception { Class.forName(JDBC_DRIVER); Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); Statement stmt = conn.createStatement(); conn.setAutoCommit(false); // 取消自动提交 try { stmt.addBatch(\"INSERT INTO member(name) VALUES ('测试AAAAACA')\"); stmt.addBatch(\"INSERT INTO member(name) VALUES (17，sd)\"); stmt.addBatch(\"INSERT INTO member(name) VALUES ('测试CCCC')\"); int result[] = stmt.executeBatch(); // 执行批处理 System.out.println(Arrays.toString(result)); conn.commit(); // 如果没有出现异常，则提交 }catch (Exception e){ e.printStackTrace(); conn.rollback(); // 如果出现异常，则进行回滚 } conn.close(); } 日后容器会帮助我们自动处理，不需要手工处理。 4. 总结 掌握批处理的执行操作 Connection 接口定义了事物的处理方法： setAutoCommit()、commit()、rollback()。","link":"/2018/11/05/Java_57_Java数据库编程_JDBC/"},{"title":"java参数传递类型的理解","text":"总结Java的参数传递类型是值传递，没有引用传递！！！ 如果参数是基本类型，传递的是基本类型的字面量值的拷贝。 如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。 1. 形参和实参的区别参数有形式参数和实际参数之分，形式参数是值传递，实际参数则是引用传递。 值传递：方法调用时，实际参数把它的值复制一份传递给对应的形式参数，方法执行中形式参数值的改变不影响实际参 数的值 引用传递：也称为传地址。方法调用时，实际参数的引用（地址，而不是参数的值）被传递给方法中相对应的形式参数，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的值 2. Java的基本类型和引用类型的区别 对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。 对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。 3. Java的参数传递举例Java的参数传递类型是值传递 如果参数是基本类型，传递的是基本类型的字面量值的拷贝。 如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。 参数是基本类型12345678910111213141516171819public class Solution { // static 函数可以被 static方法直接访问，不需要创建对象 public static void change(int i, int j) { int temp = i; i = j; j = temp; } public static void main(String[] args) { int a = 3; int b = 4; change(a, b); System.out.println(\"a = \" + a); // a = 3 System.out.println(\"b = \" + b); // b = 4 // 对实际参数没有影响，值传递 }} #####参数是引用类型 传递的是该参量所引用的对象在堆中地址值的拷贝 12345// 定义一个类public class TreeNode { int val = 0; }} 123456789101112131415public class Solution { public static void add(TreeNode root) { // 对该地址指向的对象进行操作，会影响对象的内部变量，不会改变对象的地址 root.val += 1; } public static void main(String args[]) { // 创建一个对象 root TreeNode root = new TreeNode(); // 传递地址的拷贝 add(root); System.out.println(root.val); // 输出 1，证明对root对象产生了影响，传递的是对象地址拷贝 } }","link":"/2019/10/28/java中的参数传递类型/"},{"title":"python的主函数main的理解","text":"原理__name__ 是当前模块名，通过程序入口main函数,当模块被直接运行时模块名为 __main__。当模块被直接运行时，代码将被运行，当模块是被导入时，代码不被运行 if __name__ == 'main'语句的含义： Make a script both importable and executable。使脚本模块即可以被导入到别的模块中，也可以自己执行 举例在test.py中写以下代码： 1234567print(\"start\")def main(): print(\"main 函数执行\") if __name__ == '__main__': main() print('end') 输出为： 123start main 函数执行end 如果在别的文件中导入该模块，新建 import_test.py，输入import test，运行后输出 start，__name__ == '__main__'没有执行 原理解读： 每个python模块（python文件）都包含内置的变量__name__，当运行模块被执行的时候，__name__等于文件名（包含了后缀.py）。如果import到其他模块中，则__name__等于模块名称（不包含后缀.py）。而__main__等于当前执行文件的名称（包含了后缀.py）。所以当模块被直接执行时，__name__ == '__main__'结果为真；而当模块被import到其他模块中时，__name__ == '__main__'结果为假，就是不调用对应的方法。 使用调试代码的时候，在if __name__ == '__main__'中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！","link":"/2019/10/29/python的主函数main的作用/"},{"title":"Chapter 58 DAO设计模式_分层设计思想","text":"DAO设计模式_分层设计思想，业务层与数据层的开发。 DAO 设计模式-分层设计思想1. 分层设计思想 程序的分层每一层都是独立的，可以与其他层进行完整的交互。 整个项目中，后台业务层是最核心的部分。业务层是整个程序提供的操作功能，一个业务层的操作要完成需要多个数据层的操作一起完成。整个过程中：发现数据库完成的只是一个个原子性的数据开发库。在实际的开发中，每个业务要牵扯到多个原子性的操作\b，也就是说所有的原子性的操作业务最终在业务层完成。 数据层：又被称为数据访问层（Data Access Object，DAO），是专门进行数据库的原子性操作，也就是说在数据层之中最需要控制的就是 JDBC 中的 PreparedStatement 接口的使用； 业务层：又被称为业务对象（Business Object，BO），但是现在又有一部分认为应该将其成为服务层（Service），业务层核心的目的是调用多个数据层的操作以完成整体的项目的业务设计，这个是整个项目的核心所在。 2. 业务设计实例现在要求使用 emp 表（empno、ename、job、hiredate、sal、comm）实现如下的操作功能： 【业务层】：实现雇员数据的添加，但是需要保证被添加的雇员编号不会重复； 【数据层】：判断要增加的雇员编号是否存在； 【数据层】：如果雇员编号不存在则进行数据的保存操作 【业务层】：实现雇员数据的修改操作 【数据层】：执行数据的修改操作 【业务层】：实现多个雇员数据的删除操作 【数据层】：执行雇员的执行删除操作 【业务层】：可以根据雇员编号查找到一个雇员的信息 【数据层】：根据雇员编号查询指定的雇员数据 【业务层】：可以查询所有雇员的\b信息 \b【数据层】：查询全部雇员数据 【业务层】：可以实现数据的分页显示（模糊查询），同时又可以返回所有的雇员的数量 【数据层】：雇员数据的分页查询； 【数据层】：使用 COUNT() 函数统计出所有的雇员数量 结论：用户所提出的所有的需求都应该划分为业务层，因为他指的是功能，而开发人员必须要根据业务层进行数据层的设计。 开发人员必须要根据业务层进行数据层的设计。 3. 数据库连接类 项目准备 首先可以设置一个项目名称：DAOProject，并且由于此项目需要使用 Oracle 数据库，需要为其配置好驱动程序。请保证数据库已经打开监听与实例服务。s 为了方便统一管理，父包定义为：cn.mldn，子包要根据不同的功能模块进行划分 数据库连接类数据库连接对象的取得和数据库关闭操作。保存在 dbc 子包中。构造方法中实现数据库的连接。 示例：定义数据库的专属连接类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.mldn.dbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;/** * 本类专门负责数据库的连接与关闭操作，在实例化本类对象时就意味着要进行数据的开发 * 所以在本类的构造方法里要进行数据库驱动加载与数据库连接取得 */public class DatabaseConnection { private static final String DBDRIVER = \"com.mysql.jdbc.Driver\"; private static final String DBURL = \"jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8\"; private static final String USER = \"root\"; private static final String PASS = \"admin\"; private Connection connection = null; /** * 在构造方法里面为 conn 对象进行实例化，可以直接取得数据库的连接对象 */ public DatabaseConnection(Connection conn) { try{ Class.forName(DBDRIVER); this.connection = DriverManager.getConnection(DBURL,USER,PASS); }catch (Exception e){ // 此处虽然有异常，但是抛出的意义不大 e.printStackTrace(); } } /** * 取得一个数据库的连接对象 * @return Connection 实例化对象 */ public Connection getConnection() { return this.connection; } /** * 负责数据库关闭 */ public void close(){ if(this.connection != null){ // 表示现在有连接对象 try { this.connection.close(); } catch (SQLException e) { e.printStackTrace(); } } }} 初始设计 额外话题：从最早的 DAO 设计模式来讲实际上还会考虑到一个问题，多数据库间的移植问题，此时就需要设置一个专门的表示连接标准的\b接口。 考虑到现实开发中，第三方框架越来越完善，以上复杂的设计几乎不出现了。 4. 开发\b Value Object VO 类 在实际的工作之中，针对于简单 Java 类的开发给出如下的要求： 考虑到日后程序有可能出现的分布式应用问题，所以简单 Java 类必须要实现 java.io.Serializable 接口； 简单 Java 类的名称必须与表名称保持一致； 有可能采用这样的名字：student_info，类名称为：StudentInfo； 类中的属性不允许使用基本数据类型，都必须使用基本数据类型的包装类； 基本数据类型的数值型默认值是 0，而如果是包装类默认值就是 null； 类中的属性必须使用 private \b封装，封装后的属性必须提供有 setter、getter 方法 类中可以定义有多个构造方法，但是必须要保留有一个无参构造方法； 【可选要求，基本不用】：覆写 equals()、toString()、hashCode();123456789CREATE TABLE IF NOT EXISTS emp( empno INT NOT NULL AUTO_INCREMENT, ename VARCHAR(20), job VARCHAR(20), hiredate DATE, sal DOUBLE, comm DOUBLE, PRIMARY KEY(empno))DEFAULT CHARSET=utf8; 将所有的简单 \bJava 类保存在 vo 包中。 1234567891011121314package cn.mldn.vo;import java.io.Serializable;import java.util.Date;// (\"serial\") 是序列化警告，当实现了序列化接口的类上缺少serialVersionUID属性的定义时，会出现黄色警告。可以使用@SuppressWarnings将警告关闭@SuppressWarnings(\"serial\")public class Emp implements Serializable { private Integer empno; private String ename; private String job; private Date hiredate; private Double sal; private Double comm; // setter、getter 方法省略} 不管有多少张表，只要是实体表，那么一定要写简单 Java 类，而且不要试图想要一次性将所有的表都转换到位。 数据层5. 数据层接口，开发数据层数据层最终是交给业务层进行调用的，所有业务层必须知道数据层的执行标准，即：业务层需要明确的知道数据层。 开发数据层操作标准 【重点】：对于数据层的接口给出如下的开发要求： 数据层既然是进行数据操作的，那么就将其保存在 dao 包下； 既然不同的数据表的操作有可能使用不同的数据层开发，\b那么就针对数据表进行命名 emp 表，那么数据层的接口就应该定义为 IEmpDAO； 对于整个数据层的开发严格来讲就只有两类功能： 数据更新：建议他的操作方法以 doXxx() 的姓氏命名，例如 doCreate()、doUpdate()、doRemove()； 数据查询：对于查询分为两种形式： 查询表中数据：以 findXxx() 形式命名，例如 findById()、findByName()、findAll()； 统计表中的数据：以 getXxx() 形式命名，例如 getAllCount() 示例：编写 EMP 表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package cn.mldn.dao;import cn.mldn.vo.Emp;import java.util.List;import java.util.Set;/** * 定义 emp 表的数据层的操作标准 */public interface IEmpDAO { /** * 实现数据的增加操作 * @param vo 包含了要增加数据的 VO 对象 * @return 数据保存成功返回 true，否则返回 false * @throws Exception SQL 执行异常 */ public boolean doCreate(Emp vo) throws Exception; /** * 实现数据的修改操作，本次修改是根据 id 进行全部字段的修改 * @param vo 包括了要修改数据的信息，一定要提供有 ID 内容 * @return 数据修改成功返回 true，否则返回 false * @throws Exception SQL 执行异常 */ public boolean doUpdate(Emp vo) throws Exception; /** * 执行数据的批量删除操作，所有要删除的数据以 Set 集合的形式保存 * @param ids 包含了所有要删除的数据 ID，不包含重复内容 * @return 删除成功返回 true（删除的数据个数与要删除的数据个数相同），否则返回 false * @throws Exception SQL 执行异常 */ public boolean doRemoveBatch(Set&lt;Integer&gt; ids) throws Exception; /** * 根据雇员编号查询指定的雇员信息 * @param id 要查询的雇员编号 * @return 如果雇员信息存在，数据以 VO 类对象的形式返回；如果雇员信息不存在，则返回 null * @throws Exception SQL 执行异常 */ public Emp findById(Integer id) throws Exception; /** * 查询指定数据表的全部记录，并且以集合的形式返回 * @return 表中有数据，则将数据封装为 VO 类对象然后利用 List 集合返回，&lt;br&gt; * 如果没有数据，那么集合的长度为 0（size() == 0，不是 null）&lt;/&gt; * @throws Exception SQL 执行异常 */ public List&lt;Emp&gt; findAll() throws Exception; /** * 分页进行数据的模糊查询，查询结果以集合的形式返回 * @param offset 数据行的偏移量 * @param maxNum 数据行的最大数目 * @param column 进行模糊查询的数据列 * @param keyWord 模糊查询的关键字 * @return 中有数据，则将数据封装为 VO 类对象然后利用 List 集合返回，&lt;br&gt; * 如果没有数据，那么集合的长度为 0（size() == 0，不是 null）&lt;/&gt; * @throws Exception SQL 执行异常 */ public List&lt;Emp&gt; findAllSplit(Integer offset,Integer maxNum,String column,String keyWord) throws Exception; /** * 进行模糊查询数据量的统计，如果表中没有记录统计的结果就是 0 * @param column 进行模糊查询的数据列 * @param keyWord 模糊查询的关键字 * @return 返回表中的数据量，如果没有数据就返回 0 * @throws Exception SQL 执行异常 */ public Integer getAllCount(String column,String keyWord) throws Exception;} \b示意图： 6. 数据实现类数据层需要被业务层调用，数据层需要进行数据库的执行（\bPreparedStatement），要执行多个数据层的调用，所以数据库的打开与关闭操作应该由\b业务层控制。 所有的数据层实现类要求保存在 dao.impl 子包下。 范例：EmpDAOImpl 子类 不用关闭，关闭给业务层做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package cn.mldn.dao.impl;import cn.mldn.dao.IEmpDAO;import cn.mldn.vo.Emp;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Set;public class EmpDAOImpl implements IEmpDAO { private Connection conn; private PreparedStatement pstmt; /** * 如果想要使用数据层进行原子性的功能操作实现，必须要提供有 Connection 接口对象 * 另外，由于开发之中业务层要调用数据层，所以数据库的打开与关闭交由业务层处理 * @param conn 表示数据库的连接对象 */ public EmpDAOImpl(Connection conn){ this.conn = conn; } @Override public boolean doCreate(Emp vo) throws Exception { String sql = \"INSERT INTO emp(empno,ename,job,hiredate,sal,comm) VALUES(?,?,?,?,?,?)\"; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setInt(1,vo.getEmpno()); this.pstmt.setString(2,vo.getEname()); this.pstmt.setString(3,vo.getJob()); this.pstmt.setDate(4,new java.sql.Date(vo.getHiredate().getTime())); this.pstmt.setDouble(5,vo.getSal()); this.pstmt.setDouble(6,vo.getComm()); return this.pstmt.executeUpdate() &gt; 0; } @Override public boolean doUpdate(Emp vo) throws Exception { String sql = \"UPDATE emp SET ename=?,job=?,hiredate=?,sal=?,comm=? WHERE empno=?\"; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setString(1,vo.getEname()); this.pstmt.setString(2,vo.getJob()); this.pstmt.setDate(3,new java.sql.Date(vo.getHiredate().getTime())); this.pstmt.setDouble(4,vo.getSal()); this.pstmt.setDouble(5,vo.getComm()); this.pstmt.setInt(6,vo.getEmpno()); return this.pstmt.executeUpdate() &gt; 0; } @Override public boolean doRemoveBatch(Set&lt;Integer&gt; ids) throws Exception { if(ids == null || ids.size() == 0){ // 没有要删除的数据 return false; } StringBuffer sql = new StringBuffer(); sql.append(\"DELETE FROM emp WHERE empno IN (\"); Iterator&lt;Integer&gt; iter = ids.iterator(); while(iter.hasNext()){ sql.append(iter.next()).append(\",\"); } sql.delete(sql.length()-1,sql.length()).append(\")\"); this.pstmt = this.conn.prepareStatement(sql.toString()); return this.pstmt.executeUpdate() == ids.size(); } @Override public Emp findById(Integer id) throws Exception { Emp vo = null; String sql = \"SELECT empno,ename,job,hiredate,sal,comm FROM emp WHERE empno=?\"; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setInt(1,id); ResultSet rs = this.pstmt.executeQuery(); while(rs.next()){ vo = new Emp(); vo.setEmpno(rs.getInt(1)); vo.setEname(rs.getString(2)); vo.setJob(rs.getString(3)); vo.setHiredate(rs.getDate(4)); vo.setSal(rs.getDouble(5)); vo.setComm(rs.getDouble(6)); } return vo; } @Override public List&lt;Emp&gt; findAll() throws Exception { List&lt;Emp&gt; all = new ArrayList&lt;Emp&gt;(); String sql = \"SELECT empno,ename,job,hiredate,sal,comm FROM emp\"; this.pstmt = this.conn.prepareStatement(sql); ResultSet rs = this.pstmt.executeQuery(); while(rs.next()){ Emp vo = new Emp(); vo.setEmpno(rs.getInt(1)); vo.setEname(rs.getString(2)); vo.setJob(rs.getString(3)); vo.setHiredate(rs.getDate(4)); vo.setSal(rs.getDouble(5)); vo.setComm(rs.getDouble(6)); all.add(vo); } return all; } @Override public List&lt;Emp&gt; findAllSplit(Integer offset, Integer maxNum, String column, String keyWord) throws Exception { List&lt;Emp&gt; all = new ArrayList&lt;Emp&gt;(); String sql = \" SELECT * FROM \" + \" (SELECT empno,ename,job,hiredate,sal,comm FROM emp WHERE \" + column + \" LIKE ? ) as total \" + \" LIMIT ?,? \"; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setString(1,\"%\"+keyWord+\"%\"); this.pstmt.setInt(2,offset); this.pstmt.setInt(3,maxNum); ResultSet rs = this.pstmt.executeQuery(); while(rs.next()){ Emp vo = new Emp(); vo.setEmpno(rs.getInt(1)); vo.setEname(rs.getString(2)); vo.setJob(rs.getString(3)); vo.setHiredate(rs.getDate(4)); vo.setSal(rs.getDouble(5)); vo.setComm(rs.getDouble(6)); all.add(vo); } return all; } @Override public Integer getAllCount(String column, String keyWord) throws Exception { String sql = \"SELECT COUNT(empno) FROM emp WHERE \" + column + \" LIKE ?\" ; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setString(1,\"%\"+keyWord+\"%\"); ResultSet rs = this.pstmt.executeQuery(); while(rs.next()){ return rs.getInt(1); } return null; }} 子类里面唯一要注意的就是要接收一个 Connection 接口对象。 7. 定义数据层工厂类 – DAOFactory业务层要想进行数据层的调用，那么必须要取得 IEmpDAO 接口对象，但是不同层之间如果想要取得接口对象示例，需要使用工厂设计模式，\b这个工厂类将其保存在 factory 子包下。 示例：定义工厂类 1234567891011package cn.mldn.factory;import cn.mldn.dao.IEmpDAO;import cn.mldn.dao.impl.EmpDAOImpl;import java.sql.Connection;public class DAOFactory { public static IEmpDAO getIEmpDAOInstance(Connection conn){ return new EmpDAOImpl(conn); }} 使用工厂类的特征就是外层不需要知道具体的子类。 业务层8. \b开发业务层，业务层接口 - IEmpService业务层也可以成为 Service 层，既然描述的是 emp 表的操作，所以名称就定义为 IEmpService，并且保存在 service 子包下，但是对于业务层的方法定义没有明确的要求。（建议有一定的规范！） 注意：数据层使用包装类，业务层使用基本类型delete(Set ids) 只能使用包装类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.mldn.service;import cn.mldn.vo.Emp;import java.util.List;import java.util.Map;import java.util.Set;/** * 定义 emp 表的业务层的执行标准，此类一定要负责数据库的打开与关闭操作 * 此类可以通过 DAOFactory 类取得 IEmpDAO 接口对象 */public interface IEmpService { /** * 实现雇员数据的增加操作，本次要调用 IEmpDAO 接口中的如下方法：&lt;br&gt; * &lt;li&gt;需要调用 IEmpDAO.findById() 方法，判断要增加数据的 id 是否存在&lt;/&gt; * &lt;li&gt;如果现在要增加的数据编号不存在则调用 IEmpDAO.doCreate() 方法，返回操作结果&lt;/li&gt; * @param vo 包含了要增加数据的 VO 对象 * @return 如果要增加数据的 ID 重复或者保存失败则返回 false，否则返回 true * @throws Exception SQL 执行异常 */ public boolean insert(Emp vo) throws Exception; /** * 实现雇员数据的修改操作，本次要调用 IEmpDAO.doUpdate() 方法，本次修改属于全部内容修改 * @param vo 包含了要修改数据的 VO 对象 * @return 修改成功返回 true，否则返回 false * @throws Exception SQL 执行异常 */ public boolean update(Emp vo) throws Exception; /** * 执行雇员数据的删除操作，可以删除多个雇员信息，调用 IEmpDAO.doRemoveBatch() 方法 * @param ids 包含了全部要删除数据的集合，没有重复数据 * @return 删除成功返回 true，否则返回 false * @throws Exception SQL 执行异常 */ public boolean delete(Set&lt;Integer&gt; ids) throws Exception; /** * 根据雇员编号查找雇员的完整信息，调用 IEmpDAO.findById() 方法 * @param ids 要查找的雇员编号 * @return 如果找到了则雇员信息以 VO 对象返回，否则返回 null * @throws Exception SQL 执行异常 */ public Emp get(int ids) throws Exception; /** * 查询全部雇员信息，调用 IEmpDAO.findAll() 方法 * @return 查询结果以 List 集合形式返回，如果没有数据则返回集合的长度为 0 * @throws Exception SQL 执行异常 */ public List&lt;Emp&gt; list() throws Exception; /** * 实现数据的模糊查询与数据统计，调用 IEmpDAO 中的两个方法&lt;br&gt; * &lt;li&gt;调用 IEmpDAO.findAllSplit() 方法，查询出所有的表数据，返回 List&lt;Emp&gt; &lt;/&gt; * &lt;li&gt;调用 IEmpDAO.getAllCount() 方法，查询所有的数据量，返回的 Integer &lt;/&gt;&lt;/&gt; * @param offset 数据行的偏移量 * @param maxNum 数据行的最大数目 * @param column 进行模糊查询的数据列 * @param keyWord 模糊查询的关键字 * @return 本方法需要返回多种数据类型，所以使用 Map 集合返回，由于类型不统一，所有 value 的类型设置为以下两种：&lt;br&gt; * &lt;li&gt;key = allEmps, value = IEmpDAO.findAllSplit() 返回结果，List&lt;Emp&gt;;&lt;/&gt; * &lt;li&gt;key = empCount, value = IEmpDAO.getAllCount() 返回结果，Integer &lt;/&gt;&lt;/&gt; * @throws Exception SQL 执行异常 */ public Map&lt;String,Object&gt; list(int offset,int maxNum,String column,String keyWord) throws Exception;} 9. 业务层实现类业务层实现类的核心功能： 负责控制数据库的\b打开和关闭：当存在了业务层对象后其目的就是为操作数据库，即：业务层对象实例化之后就必须准备好数据连接； 根据 DAOFactory 调用 getIEmpDAOInstance() 方法 \b而后取得 IEmpDAO 接口对象 业务层的实现类保存在 dao.impl 子包中。 示例：定义 EmpServiceImpl 子类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package cn.mldn.dao.impl;import cn.mldn.dbc.DatabaseConnection;import cn.mldn.factory.DAOFactory;import cn.mldn.service.IEmpService;import cn.mldn.vo.Emp;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Set;public class EmpServiceImpl implements IEmpService { // 在这个类的对象内部提供有一个数据库连接类的实例化对象 private DatabaseConnection dbc = new DatabaseConnection(); @Override public boolean insert(Emp vo) throws Exception { try{ // 要增加的雇员编号如果不存在，则 findById() 返回的结果就是 null，null 表示可以进行新雇员数据的保存 if(DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()).findById(vo.getEmpno()) == null){ return DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()).doCreate(vo); } return false; }catch (Exception e){ throw e; }finally { this.dbc.close(); } } @Override public boolean update(Emp vo) throws Exception { try{ return DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()).doUpdate(vo); }catch(Exception e){ throw e; }finally { this.dbc.close(); } } @Override public boolean delete(Set&lt;Integer&gt; ids) throws Exception { try { return DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()).doRemoveBatch(ids); }catch(Exception e){ throw e; }finally { this.dbc.close(); } } @Override public Emp get(int ids) throws Exception { try{ return DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()).findById(ids); }catch(Exception e){ throw e; }finally{ this.dbc.close(); } } @Override public List&lt;Emp&gt; list() throws Exception { try{ return DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()).findAll(); }catch(Exception e){ throw e; }finally{ this.dbc.close(); } } @Override public Map&lt;String, Object&gt; list(int offset, int maxNum, String column, String keyWord) throws Exception { try{ Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"allEmps\",DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()).findAllSplit(offset,maxNum,column,keyWord)); map.put(\"empCount\",DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()).getAllCount(column,keyWord)); return map; }catch(Exception e){ throw e; }finally{ this.dbc.close(); } }} 不同层之间的访问依靠的\b就是工厂类和接口进行操作。 【技巧】：只要写接口\b，取得对象就使用工厂。 10. 定义业务层的工厂类：ServiceFactory业务层最终依然需要被其他的层所使用，所以需要为其定义工厂类，该类也同样保存在 factory 子包下，从开发角度来讲，业务层应该分为两种： 前台业务逻辑：可以将其保存在 service.front 包中，\b工厂类：ServiceFrontFactory 后台业务逻辑：可以将其保存在 service.back 包中，工厂类：ServiceBackFactory。 示例：定义 ServiceFactory 12345678910package cn.mldn.factory;import cn.mldn.dao.impl.EmpServiceImpl;import cn.mldn.service.IEmpService;public class ServiceFactory { public static IEmpService getIEmpServiceInstance(){ return new EmpServiceImpl(); }} 业务测试11. 调用测试示例：数据插入测试 1234567891011121314151617181920212223package cn.mldn.cn.mldn.test;import cn.mldn.factory.ServiceFactory;import cn.mldn.vo.Emp;import java.util.Date;public class TestEmpInsert { public static void main(String args[]){ Emp vo = new Emp(); vo.setEmpno(001); vo.setEname(\"Mary\"); vo.setJob(\"秘书\"); vo.setHiredate(new Date()); vo.setSal(2000.0); vo.setComm(888.0); try{ System.out.println(ServiceFactory.getIEmpServiceInstance().insert(vo)); }catch(Exception e){ e.printStackTrace(); } }} 运行第一次返回 true，第二次返回 false（\bempno 重复，无法插入） 示例：测试分页查询功能 1234567891011121314151617181920212223242526package cn.mldn.cn.mldn.test;import cn.mldn.factory.ServiceFactory;import cn.mldn.vo.Emp;import java.util.Iterator;import java.util.List;import java.util.Map;public class TestEmpSplit { public static void main(String []args){ try{ Map&lt;String,Object&gt; map = ServiceFactory.getIEmpServiceInstance().list(1,3,\"ename\",\"\"); int count = (Integer) map.get(\"empCount\"); System.out.println(\"数据量：\"+ count); List&lt;Emp&gt; all = (List&lt;Emp&gt;) map.get(\"allEmps\"); Iterator&lt;Emp&gt; iter = all.iterator(); while(iter.hasNext()){ Emp vo = iter.next(); System.out.println(\"姓名：\" + vo.getEname() + \",职业：\" + vo.getJob()); } }catch(Exception e){ e.printStackTrace(); } }} 12. 利用 junit 进行测试深入讲解13. 实现部门操作 定义 Dept.java实现简单 java 类 12345678910package cn.mldn.vo;import java.io.Serializable;public class Dept implements Serializable{ private Integer deptno; private String dname; private String loc; // 省略 setter、getter} 定义 IDeptDAO 接口几乎所有的数据表都应该具备有基础 CRUD 功能（增加、修改全部、删除数据、根据编号查询、查询全部、分页显示、数据统计），这些功能呢的方法每个接口都要重复定义。在整个 DAO 接口定义过程之中，不同表的区别在于 VO类、主键类型。 定义一个公共父类 IDAO.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package cn.mldn.dao;import java.util.List;import java.util.Set;/** * 定义公共的 DAO 操作接口标准，增加、修改全部、删除数据、根据编号查询、查询全部、分页显示、数据统计 * @param &lt;K&gt; 表示要操作的主键类型，由子接口实现 * @param &lt;V&gt; 表示要操作的 VO 类型，由子接口实现 */public interface IDAO&lt;K,V&gt; { /** * 实现数据的增加操作 * @param vo 包含了要增加数据的 VO 对象 * @return 数据保存成功返回 true，否则返回 false * @throws Exception SQL 执行异常 */ public boolean doCreate(V vo) throws Exception; /** * 实现数据的修改操作，本次修改是根据 id 进行全部字段的修改 * @param vo 包括了要修改数据的信息，一定要提供有 ID 内容 * @return 数据修改成功返回 true，否则返回 false * @throws Exception SQL 执行异常 */ public boolean doUpdate(V vo) throws Exception; /** * 执行数据的批量删除操作，所有要删除的数据以 Set 集合的形式保存 * @param ids 包含了所有要删除的数据 ID，不包含重复内容 * @return 删除成功返回 true（删除的数据个数与要删除的数据个数相同），否则返回 false * @throws Exception SQL 执行异常 */ public boolean doRemoveBatch(Set&lt;K&gt; ids) throws Exception; /** * 根据雇员编号查询指定的雇员信息 * @param id 要查询的雇员编号 * @return 如果雇员信息存在，数据以 VO 类对象的形式返回；如果雇员信息不存在，则返回 null * @throws Exception SQL 执行异常 */ public V findById(K id) throws Exception; /** * 查询指定数据表的全部记录，并且以集合的形式返回 * @return 表中有数据，则将数据封装为 VO 类对象然后利用 List 集合返回，&lt;br&gt; * 如果没有数据，那么集合的长度为 0（size() == 0，不是 null）&lt;/&gt; * @throws Exception SQL 执行异常 */ public List&lt;V&gt; findAll() throws Exception; /** * 分页进行数据的模糊查询，查询结果以集合的形式返回 * @param offset 数据行的偏移量 * @param maxNum 数据行的最大数目 * @param column 进行模糊查询的数据列 * @param keyWord 模糊查询的关键字 * @return 中有数据，则将数据封装为 VO 类对象然后利用 List 集合返回，&lt;br&gt; * 如果没有数据，那么集合的长度为 0（size() == 0，不是 null）&lt;/&gt; * @throws Exception SQL 执行异常 */ public List&lt;V&gt; findAllSplit(Integer offset,Integer maxNum,String column,String keyWord) throws Exception; /** * 进行模糊查询数据量的统计，如果表中没有记录统计的结果就是 0 * @param column 进行模糊查询的数据列 * @param keyWord 模糊查询的关键字 * @return 返回表中的数据量，如果没有数据就返回 0 * @throws Exception SQL 执行异常 */ public Integer getAllCount(String column,String keyWord) throws Exception;} 示例：定义 IEmpDAO 子接口 定义 DeptDAOImpl 子类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package cn.mldn.dao.impl;import cn.mldn.dao.IDeptDAO;import cn.mldn.vo.Dept;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Set;public class DeptDAOImpl implements IDeptDAO { private Connection conn; private PreparedStatement pstmt; public DeptDAOImpl(Connection conn) { this.conn = conn; } @Override public boolean doCreate(Dept vo) throws Exception { String sql = \"INSERT INTO dept(deptno,dname,loc) VALUES(?,?,?)\"; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setInt(1,vo.getDeptno()); this.pstmt.setString(2,vo.getDname()); this.pstmt.setString(3,vo.getLoc()); return this.pstmt.executeUpdate() &gt; 0; } @Override public boolean doUpdate(Dept vo) throws Exception { String sql = \"UPDATE dept SET dname=?,loc=? WHERE deptno=?\"; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setString(1,vo.getDname()); this.pstmt.setString(2,vo.getLoc()); this.pstmt.setInt(3,vo.getDeptno()); return this.pstmt.executeUpdate() &gt; 0; } @Override public boolean doRemoveBatch(Set&lt;Integer&gt; ids) throws Exception { if(ids == null || ids.size() == 0){ // 没有要删除的数据 return false; } StringBuffer sql = new StringBuffer(); sql.append(\"DELETE FROM dept WHERE deptno IN (\"); Iterator&lt;Integer&gt; iter = ids.iterator(); while(iter.hasNext()){ sql.append(iter.next()).append(\",\"); } sql.delete(sql.length()-1,sql.length()).append(\")\"); this.pstmt = this.conn.prepareStatement(sql.toString()); return this.pstmt.executeUpdate() == ids.size(); } @Override public Dept findById(Integer id) throws Exception { Dept vo = null; String sql = \"SELECT deptno,dname,loc FROM dept WHERE deptno=?\"; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setInt(1,id); ResultSet rs = this.pstmt.executeQuery(); while (rs.next()){ vo = new Dept(); vo.setDeptno(rs.getInt(1)); vo.setDname(rs.getString(2)); vo.setLoc(rs.getString(3)); } return vo; } @Override public List&lt;Dept&gt; findAll() throws Exception { List&lt;Dept&gt; all = new ArrayList&lt;Dept&gt;(); String sql = \"SELECT deptno,dname,loc FROM dept\"; this.pstmt = this.conn.prepareStatement(sql); ResultSet rs = this.pstmt.executeQuery(); while (rs.next()){ Dept vo = new Dept(); vo.setDeptno(rs.getInt(1)); vo.setDname(rs.getString(2)); vo.setLoc(rs.getString(3)); all.add(vo); } return all; } @Override public List&lt;Dept&gt; findAllSplit(Integer offset, Integer maxNum, String column, String keyWord) throws Exception { throw new Exception(\"此方法未实现\"); } @Override public Integer getAllCount(String column, String keyWord) throws Exception { throw new Exception(\"此方法未实现\"); }} 对于未实现的方法：抛出异常： 此方法未实现 修改 DAOFactory 类，增加新的接口对象取得方法 123public static IDeptDAO getIDeptDAOInstance(Connection conn){ return new DeptDAOImpl(conn); } 开发 IDeptService 接口业务层最好不要做方法抽象，因为面向用户，要保证所有的方法可用。 1234567891011121314package cn.mldn.service;import cn.mldn.vo.Dept;import java.util.List;import java.util.Set;public interface IDeptService { public boolean insert(Dept vo) throws Exception; public boolean update(Dept vo) throws Exception; public boolean delete(Set&lt;Integer&gt; ids) throws Exception; public Dept get(int ids) throws Exception; public List&lt;Dept&gt; list() throws Exception;} 实现 DeptServiceImpl 子类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package cn.mldn.dao.impl;import cn.mldn.dbc.DatabaseConnection;import cn.mldn.factory.DAOFactory;import cn.mldn.service.IDeptService;import cn.mldn.vo.Dept;import java.util.List;import java.util.Set;public class DeptServiceImpl implements IDeptService{ private DatabaseConnection dbc = new DatabaseConnection(); @Override public boolean insert(Dept vo) throws Exception { try{ // 要增加的dept编号如果不存在，则 findById() 返回的结果就是 null，null 表示可以进行新数据的保存 if(DAOFactory.getIDeptDAOInstance(this.dbc.getConnection()).findById(vo.getDeptno()) == null){ return DAOFactory.getIDeptDAOInstance(this.dbc.getConnection()).doCreate(vo); } return false; }catch (Exception e){ throw e; }finally { this.dbc.close(); } } @Override public boolean update(Dept vo) throws Exception { try{ return DAOFactory.getIDeptDAOInstance(this.dbc.getConnection()).doUpdate(vo); }catch(Exception e){ throw e; }finally { this.dbc.close(); } } @Override public boolean delete(Set&lt;Integer&gt; ids) throws Exception { try { return DAOFactory.getIDeptDAOInstance(this.dbc.getConnection()).doRemoveBatch(ids); }catch(Exception e){ throw e; }finally { this.dbc.close(); } } @Override public Dept get(int ids) throws Exception { try{ return DAOFactory.getIDeptDAOInstance(this.dbc.getConnection()).findById(ids); }catch(Exception e){ throw e; }finally{ this.dbc.close(); } } @Override public List&lt;Dept&gt; list() throws Exception { try{ return DAOFactory.getIDeptDAOInstance(this.dbc.getConnection()).findAll(); }catch(Exception e){ throw e; }finally { this.dbc.close(); } }} 修改服务层工厂类 123 public static IDeptService getIDeptServiceInstance() { return new DeptServiceImpl(); } 14. 处理关系（了解）已经实现了雇员和部门的基础操作，但是在雇员里面存在有 mgr 和 deptno 两个关联对象，修改 VO 类的定义； 修改 Emp.java 类，SQL 数据表也要变化 123private Emp mgr;private Dept dept;// 增加这两个属性及其 setter、getter 方法 修改 Dept.java 类 1234567private List&lt;Emp&gt; emps; public List&lt;Emp&gt; getEmps() { return emps; } public void setEmps(List&lt;Emp&gt; emps) { this.emps = emps; } 增加数据要变化： 123456789101112131415161718192021public boolean doCreate(Emp vo) throws Exception { String sql = \"INSERT INTO emp(empno,ename,job,hiredate,sal,comm,mgr,dept) VALUES(?,?,?,?,?,?,?,?)\"; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setInt(1,vo.getEmpno()); this.pstmt.setString(2,vo.getEname()); this.pstmt.setString(3,vo.getJob()); this.pstmt.setDate(4,new java.sql.Date(vo.getHiredate().getTime())); this.pstmt.setDouble(5,vo.getSal()); this.pstmt.setDouble(6,vo.getComm()); if(vo.getMgr() == null){ // 未设置领导数据 this.pstmt.setNull(7, Type.NULL); }else{ this.pstmt.setInt(7,vo.getMgr().getEmpno()); } if(vo.getDept() == null){ this.pstmt.setNull(8, Type.NULL); }else{ this.pstmt.setInt(8,vo.getDept().getDeptno()); } return this.pstmt.executeUpdate() &gt; 0; } 修改数据也要变化： 12345678910111213141516171819202122public boolean doUpdate(Emp vo) throws Exception { String sql = \"UPDATE emp SET ename=?,job=?,hiredate=?,sal=?,comm=?,mgr=?,dept=? WHERE empno=?\"; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setString(1,vo.getEname()); this.pstmt.setString(2,vo.getJob()); this.pstmt.setDate(3,new java.sql.Date(vo.getHiredate().getTime())); this.pstmt.setDouble(4,vo.getSal()); this.pstmt.setDouble(5,vo.getComm()); if(vo.getMgr() == null){ // 未设置领导数据 this.pstmt.setNull(6, Type.NULL); }else{ this.pstmt.setInt(6,vo.getMgr().getEmpno()); } if(vo.getDept() == null){ this.pstmt.setNull(7, Type.NULL); }else{ this.pstmt.setInt(7,vo.getDept().getDeptno()); } this.pstmt.setInt(8,vo.getEmpno()); return this.pstmt.executeUpdate() &gt; 0; } 查询单个雇员信息的时候也要进行全部内容的查询。需要进行多表查询，那么在 IEmpDAO 中扩充功能。 1234567891011121314151617181920212223242526272829public interface IEmpDAO extends IDAO&lt;Integer,Emp&gt;{ /** * 查询雇员的详细信息，包括雇员对应的领导信息和所在部门的信息 * @param id 要查询的雇员编号 * @return 所有的数据以 VO 对象返回，如果没有则返回 null * @throws Exception SQL 异常 */ public Emp findByIdDetails(Integer id) throws Exception; /** * 查询雇员的完整信息 * @return 所有的数据对象以 List 集合返回，如果没有数据集合长度为 0（size == 0） * @throws Exception SQL 查询错误 */ public List&lt;Emp&gt; findAllDetails() throws Exception; /** * 分页进行数据的模糊查询，查询结果以集合的形式返回 * @param offset 数据行的偏移量 * @param maxNum 数据行的最大数目 * @param column 进行模糊查询的数据列 * @param keyWord 模糊查询的关键字 * @return 中有数据，则将数据封装为 VO 类对象然后利用 List 集合返回，&lt;br&gt; * 如果没有数据，那么集合的长度为 0（size() == 0，不是 null）&lt;/&gt; * @throws Exception SQL 执行异常 */ public List&lt;Emp&gt; findAllSplitDetails(Integer offset,Integer maxNum,String column,String keyWord) throws Exception;} 实现细节： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100@Override public Emp findByIdDetails(Integer id) throws Exception { Emp vo = null; String sql = \"SELECT e.ename,e.job,e.hiredate,e.sal,e.comm, \" + \"m.empno,m.ename, \" + \"d.deptno,d.name,d.loc \"+ \"FROM emp e,emp m,dept d \" + \"WHERE e.mgr=m.empno AND e.dept=d.deptno AND e.empno=?\"; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setInt(1,id); ResultSet rs = this.pstmt.executeQuery(); while(rs.next()){ vo = new Emp(); vo.setEname(rs.getString(1)); vo.setJob(rs.getString(2)); vo.setHiredate(rs.getDate(3)); vo.setSal(rs.getDouble(4)); vo.setComm(rs.getDouble(5)); Emp mgr = new Emp(); mgr.setEmpno(rs.getInt(6)); mgr.setEname(rs.getString(7)); vo.setMgr(mgr); Dept dept = new Dept(); dept.setDeptno(rs.getInt(8)); dept.setDname(rs.getString(9)); dept.setLoc(rs.getString(10)); vo.setDept(dept); } return vo; } @Override public List&lt;Emp&gt; findAllDetails() throws Exception { List&lt;Emp&gt; all = new ArrayList&lt;Emp&gt;(); String sql = \"SELECT e.empno,e.ename,e.job,e.hiredate,e.sal,e.comm, \" + \"m.empno,m.ename, \" + \"d.deptno,d.name,d.loc \"+ \"FROM emp e,emp m,dept d \" + \"WHERE e.mgr=m.empno AND e.dept=d.deptno\"; this.pstmt = this.conn.prepareStatement(sql); ResultSet rs = this.pstmt.executeQuery(); while(rs.next()){ Emp vo = new Emp(); vo.setEmpno(rs.getInt(1)); vo.setEname(rs.getString(2)); vo.setJob(rs.getString(3)); vo.setHiredate(rs.getDate(4)); vo.setSal(rs.getDouble(5)); vo.setComm(rs.getDouble(6)); Emp mgr = new Emp(); mgr.setEmpno(rs.getInt(7)); mgr.setEname(rs.getString(8)); vo.setMgr(mgr); Dept dept = new Dept(); dept.setDeptno(rs.getInt(9)); dept.setDname(rs.getString(10)); dept.setLoc(rs.getString(11)); vo.setDept(dept); all.add(vo); } return all; } @Override public List&lt;Emp&gt; findAllSplitDetails(Integer offset, Integer maxNum, String column, String keyWord) throws Exception { List&lt;Emp&gt; all = new ArrayList&lt;Emp&gt;(); String sql = \"SELECT * FROM( \" + \" SELECT e.empno,e.ename,e.job,e.hiredate,e.sal,e.comm, \" + \" m.empno mno,m.ename mname,d.deptno dno,d.dname,d.loc \"+ \" FROM emp e,emp m,dept d \" + \" WHERE e.mgr=m.empno AND e.dept=d.deptno \" + \" AND e.\" + column + \" LIKE ?) as total \" + \" LIMIT ?,? \"; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setString(1,\"%\"+keyWord+\"%\"); this.pstmt.setInt(2,offset); this.pstmt.setInt(3,maxNum); ResultSet rs = this.pstmt.executeQuery(); while(rs.next()){ Emp vo = new Emp(); vo.setEmpno(rs.getInt(1)); vo.setEname(rs.getString(2)); vo.setJob(rs.getString(3)); vo.setHiredate(rs.getDate(4)); vo.setSal(rs.getDouble(5)); vo.setComm(rs.getDouble(6)); Emp mgr = new Emp(); mgr.setEmpno(rs.getInt(7)); mgr.setEname(rs.getString(8)); vo.setMgr(mgr); Dept dept = new Dept(); dept.setDeptno(rs.getInt(9)); dept.setDname(rs.getString(10)); dept.setLoc(rs.getString(11)); vo.setDept(dept); all.add(vo); } return all; } 修改服务层接口，IEmpService：这里为了简单，只实现了一个方法接口 1public Map&lt;String,Object&gt; listDetails(int offset,int maxNum,String column,String keyWord) throws Exception; 修改服务层实现 EmpServiceImpl： 12345678910111213@Override public Map&lt;String, Object&gt; listDetails(int offset, int maxNum, String column, String keyWord) throws Exception { try{ Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"allEmps\",DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()).findAllSplitDetails(offset,maxNum,column,keyWord)); map.put(\"empCount\",DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()).getAllCount(column,keyWord)); return map; }catch(Exception e){ throw e; }finally{ this.dbc.close(); } }","link":"/2018/11/05/Java_58_DAO设计模式_分层设计思想/"},{"title":"git 学习笔记","text":"这里是笔记摘要：廖雪峰的Git教程：史上最浅显易懂的Git教程！本教程面向初学者，没有接触过版本控制概念的读者也可以轻松入门，不必担心起步难度；其次，本教程实用性超强，边学边练，一点也不觉得枯燥。而且，你所学的Git命令是“充分且必要”的，掌握了这些东西，你就可以通过Git轻松地完成你的工作。 Github学习笔记廖雪峰的Git教程：史上最浅显易懂的Git教程！ Git简介 集中式版本控制系统： 版本库集中存放在中央服务器，工作时要先从中央服务器取得最新的版本，工作结束后把自己的工作推送给中央服务器。 缺点:* 必须联网才能工作。 分布式版本控制系统： 分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，所以不需要联网。 多人协作：* 比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 Git安装及配置Linux 安装Git 的命令：sudo apt-get install gitGit 设置用户名和email地址的命令： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 注意：git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库 初始化一个Git仓库，在该目录下使用git init当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的,默认是隐藏的，用ls -ah命令就可以看见。 添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意:可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 版本回退 git status命令可以让我们时刻掌握仓库当前的状态 git diff\b查看上次修改的具体内容 git reset --hard HEAD^,回退到上一个版本 HEAD指向的版本就是当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 git reset --hard commit_id,在版本的历史之间穿梭 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本 工作区和暂存区 Git的版本库：工作区有一个隐藏目录.git。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 管理修改 文件添加到Git版本库 git add把文件添加进去，实际上就是把文件修改添加到暂存区； git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以git commit就是往master分支上提交更改。可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： 撤销修改 git diff HEAD -- &lt;file&gt;提交后用该命令可以查看工作区和版本库里面最新版本的区别 git checkout -- &lt;file&gt;，把&lt;file&gt;文件在工作区的修改全部撤销，这里有两种情况： &lt;file&gt;自修改后还没有被放到暂存区，现在撤销修改就回到和版本库一模一样的状态； &lt;file&gt;已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。注意： git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令 git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区 git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。 小结： 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除修改 先手动删除文件(工作区删除）,然后从版本库中删除该文件，并且git commit123$ rm &quot;filename&quot;$ git rm &lt;file&gt;$ git commit -m &quot;remove ...&quot; 小提示： 先手动删除文件，然后使用git rm &lt;file&gt;和git add&lt;file&gt;效果是一样的。 删错了版本库中有，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout -- &lt;file&gt;git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 小结： 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 远程仓库添加远程库 要关联一个远程库,本地的learngit仓库下运行命令：12$ git remote add origin git@server-name:path/repo-name.git// $ git remote add origin git@github.com:fujiao9614/fujiao9614.github.io.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的. 下一步，就可以把本地库的所有内容推送到远程库上： 把本地库的内容推送到远程，使用命令git push -u origin master第一次推送master分支的所有内容.由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。从现在起，只要本地作了提交，就可以通过命令：$ git push origin master 从远程库克隆要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。$ git clone git@server-name:path/repo-name.git 分支管理创建合并分支 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 git log --graph命令可以看到分支合并图。1$ git log --graph --pretty=oneline --abbrev-commit 分支管理 Git分支十分强大，在团队开发中应该充分应用。$ git merge --no-ff -m &quot;merge with no-ff&quot; dev合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并 $ git stash，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：git stash list查看stash内容 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了：多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：$ git stash apply stash@{0} Bug分支和feature分支 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 开发一个新feature，最好新建一个分支；如果要删除Git会提示：新分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。因此丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 多人协作 git remote查看远程库信息;git remote -v会显示更详细的信息，例如抓取和推送的origin的地址。（如果没有推送权限，就看不到push的地址。） 多人协作的模式： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果``git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to origin/`。 小结： 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 rebase\b merge的过程它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。 rebase 合并操作来整合分叉rebase提取在C4中引入的补丁和修改-&gt;C4‘，然后在C3的基础上应用一次C3+C4’-&gt;C5。 在Git中，这种操作就叫做变基。在上面这个例子中，第一步将 C4 中的修改变基到 C3 上，在experiment进行一次快进模式合并（Fast-forward）：123&gt;$ git checkout experiment&gt;$ git rebase master&gt; 第二步：回到 master 分支，进行一次快进模式（Fast-forward） 123&gt;$ git checkout master&gt;$ git merge experiment&gt; 此时，C4’ 指向的快照就和上面使用 merge 命令的例子中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。 总结 rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 \b标签管理 git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； git tag可以查看所有标签 git show &lt;tagname&gt;可以看到说明文字 git push origin &lt;tagname&gt;可以推送一个本地标签； git push origin --tags可以推送全部未推送过的本地标签； git tag -d &lt;tagname&gt;可以删除一个本地标签； git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 注意： 标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 提示：在GitHub上，可以任意Fork开源仓库；自己拥有Fork后的仓库的读写权限；可以推送pull request给官方仓库来贡献代码。先Fork，然后clone到本地。 补充：使用GitHub挂载网站官方文档参考 使用GitHub挂载其实是使用了GitHub Pages的功能 GitHub Pages有两种用法： 如果你的仓库名为用户名.github.io的话，会自动开启GitHub Pages功能，且所有提交到master分支的代码，会当做网站内容被挂载起来，且网站访问地址为http://用户名.github.io 第二种用法，可以手动指定一个仓库的master分支，或者master分支下的/docs目录，或者gh-pages分支为网站的根目录，其下的内容为网站内容，此方法需要在仓库设置里手动开启GitHub Pages功能，并指定网站挂载方式。用第二种方法的话，挂载之后的服务器地址，在设置之后会显示在后台.","link":"/2018/10/08/git/"},{"title":"面试经验","text":"需要准备的 算法 主语言 熟悉岗位要求 操作系统、计算机网络等基础知识 项目 项目划分 自己负责的部分 遇到的难点，怎么解决的 核心代码 简历 命名要规范 ，精炼一页 技能 基本原理要懂，讲到的点可能会被深入提问 spring mvc、spring boot：要看源码 项目角色 外企：找人少，算法门槛高很难。给钱多不加班 提前批：越早投越好，提前准备，会有表现和记录 复习节奏： 大话数据结构 链表、树、排序 手写 牛客网：首先剑指offer，三遍。自己做、理解思想再刷 leetcode：有时间就刷题 基础知识：Java程序员面试宝典、Java并发编程的艺术、深入理解Java虚拟机。JVM调优，报错排查。 周末单休，建议复习基础知识【比较整块的时间】 明年2月到7月，不要放松 阅读源码：spring中的源码。精妙的设计在里面，hash、hashmap实现并发等。 机会到了要有运气抓住～ java：并发、线程锁、jvm 操作系统：进程、线程区别，进程调度 数据库：SQL 数据库和操作系统 复习点就可以。 新开的部门，会比较容易。 面试要查漏补缺，面经看多了会发现很多点会重复 公司招聘开始结束时间，可以用文档总结 情商：最近看的书，感兴趣的领域","link":"/2019/10/14/工作经验/"},{"title":"剑指offer题目练习","text":"1. 调整数组顺序使奇数位于偶数前面题目描述：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 12345678910111213141516171819public void reOrderArray(int [] array) { // 记录已经放好的奇数部分 int m = 0; for(int i = 0;i &lt; array.length; i++){ if(array[i]%2!=0){ int j = i; // 将固定好的奇数后的数组 向后挪一位 // 固定了 m 个奇数位 int temp = array[i]; while(j &gt; m){ array[j] = array[j-1]; j--; } // 现在第m位空出来了，排列第m+1个数 array[m] = temp; m++; } } } 2. 链表中倒数第k个结点题目描述：输入一个链表，输出该链表中倒数第k个结点。 解题思路：相当于制造了一个K长度的尺子，把尺子从头往后移动，当尺子的右端与链表的末尾对齐的时候，尺子左端所在的结点就是倒数第k个结点” 12345678910111213141516171819202122public ListNode FindKthToTail(ListNode head,int k) { // 如果是空链表 或者 k是负数 返回null if(head == null || k&lt;=0) return null; // 尺子的头 head1 ListNode head1 = head; // head1 先走 k-1 步 while(--k&gt;0){ // 如果head1的下一个是空，则已经移到底了，说明k超出范围了 // 返回null if(head1.next == null){ return null; } head1 = head1.next; } // 现在head 和 head1 一起走，当head1走到底的时候，head指向倒数第 n 个 while(head1.next!=null){ head1 = head1.next; head = head.next; } return head;} 3. 链表反转返回反转后链表的头节点 1234567891011121314151617181920212223242526public ListNode ReverseList(ListNode head) { ListNode pre = null; ListNode next = null; //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点 //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2 //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了 //所以需要用到pre和next两个节点 //1-&gt;2-&gt;3-&gt;4-&gt;5 //1&lt;-2&lt;-3 4-&gt;5 while(head!=null){ //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre //如此就可以做到反转链表的效果 //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 next = head.next; //保存完next，就可以让head从指向next变成指向pre了，代码如下 head.next = pre; //head指向pre后，就继续依次反转下一个节点 //让pre，head，next依次向后移动一个节点，继续下一次的指针反转 pre = head; head = next; } //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点 //直接输出pre就是我们想要得到的反转后的链表 return pre;} 4. 合并两个排序的链表题目描述：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 题解：创建一个新链表，将list1和list2中的元素追加进去 123456789101112131415161718public ListNode Merge(ListNode list1, ListNode list2) { ListNode new_list = new ListNode(0); ListNode p = new_list; while(list1!=null&amp;&amp;list2!=null){ if(list1.val&lt;list2.val){ p.next = list1; list1 = list1.next; } else{ p.next = list2; list2 = list2.next; } p = p.next; } if(list1 == null) p.next = list2; if(list2 == null) p.next = list1; return new_list.next;} 5. 顺时针打印矩阵题目描述：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10。 题解：不断地收缩矩阵的边界定义四个变量代表范围，up、down、left、right 向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错 向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错 向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错 向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) { ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // 矩阵为空，行或列的长度为空，返回空列表 if(matrix == null|| matrix.length == -1|| matrix[0].length == -1){ return res; } // 定义上下左右四个矩阵的边界 int up = 0; int down = matrix.length-1; int left = 0; int right = matrix[0].length-1; // 初始化两个变量 i代表行号,j代表列号 int i = 0,j=0; while(true){ // 从左到右遍历最上面一行，指定i=up,j从left-&gt;right for(i = up,j = left;j &lt;= right;j++){ res.add(matrix[i][j]); } // 向下逼近 up++; // 判断是否越界 if(up&gt;down){ break; } // 从上到下遍历最后一列，指定j=right，i从up-&gt;down for(j=right, i = up; i &lt;= down;i++){ res.add(matrix[i][j]); } // 向左逼近 right--; // 判断是否越界 if(right&lt;left){ break; } // 从右到左遍历最后一行，指定i=down，j从right-&gt;left for(i=down,j=right;j&gt;=left;j--){ res.add(matrix[i][j]); } // 向上逼近 down--; // 判断是否越界 if(down&lt;up){ break; } // 从下到上遍历第一列，指定j=left，i从down-&gt;up for(j=left, i=down; i &gt;= up; i--){ res.add(matrix[i][j]); } // 向右逼近 left++; // 判断是否越界 if(left&gt;right){ break; } } return res;} 6. 包含min函数的栈题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为$O(1)$） 题解：保存数据的栈s，再使用一个同步栈 sync，始终保持最小元素在sync的栈顶。 每次入栈时，调整sync，最小元素在sync的栈顶 每次出栈时，在sync中找到s的栈顶元素，也出栈 ⚠️注意： Stack的函数 boolean empty()：测试堆栈是否为空 Object peek( )：查看堆栈顶部的对象，但不从堆栈中移除它 Object pop( )：移除堆栈顶部的对象，并作为此函数的值返回该对象 Object push(Object element)：把项压入堆栈顶部 int search(Object element)：返回对象在堆栈中的位置，以 1 为基数。 判断空：如果 if 中判断是否为空和其他条件，判断是否位空必须放在其他条件的前面，短路运算。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Solution { Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); Stack&lt;Integer&gt; sync = new Stack&lt;&gt;(); public void push(int node) { // 对于 s 直接入栈 s.push(node); // 若sync为空或者 node是最小元素，则直接入栈 if(sync.empty()||sync.peek()&gt;=node){ sync.push(node); } else{ Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); // 把比node小的元素都拿出来放到temp中 // 注意 sync.empty()写在前面 while(!sync.empty() &amp;&amp; sync.peek()&lt;node){ temp.push(sync.pop()); } // 将node插入 sync.push(node); // 将temp的元素放回去 while(!temp.empty()){ sync.push(temp.pop()); } } } public void pop() { // 对于 s 直接出栈，记录出栈元素 int t = s.pop(); // 若sync的栈顶是出栈元素，则直接出栈 if(sync.peek() == t){ sync.pop(); } // 否则找到sync中出栈元素 else{ Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); while(sync.peek()!= t){ temp.push(sync.pop()); } // 出栈 sync.pop(); // 其余元素位置不变，放回 while(!temp.empty()){ sync.push(temp.pop()); } } } public int top() { return s.peek(); } public int min() { return sync.peek(); }} 7. 栈的压入、弹出序列题目描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路：按照入栈顺序进行入栈，若等于出栈元素，则进行出栈。循环结束后栈为空，即所有元素入栈并出栈。 1234567891011121314151617181920212223import java.util.Stack;public boolean IsPopOrder(int [] pushA,int [] popA) { if(pushA.length == 0||popA.length==0){ return true; } Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); int j=0; for(int i=0; i &lt; pushA.length; i++){ // 先入栈 s.push(pushA[i]); // 判断栈顶元素与待出栈元素是否相同，相同则出栈 // 若栈为空 退出while循环 while(!s.empty()&amp;&amp;s.peek()== popA[j]){ s.pop(); j++; } } // 判断条件使用 s.empty() 或者 j==popA.length都可以 if(s.empty()){ return true; } return false;} 8. 从上往下打印二叉树(Queue数据结构的使用)题目描述：从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路：首先将根节点入队列，队列元素出队后，将这个元素的左右孩子放入队列，直到队列为空 12345678910111213141516171819import java.util.Queue;import java.util.LinkedList;public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) { ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root==null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); // 首先将根节点放进去 queue.offer(root); while(!queue.isEmpty()){ // 出队列 TreeNode temp = queue.poll(); res.add(temp.val); // 放入左节点和右节点 if(temp.left!=null){queue.offer(temp.left);} if(temp.right!=null){queue.offer(temp.right);} } return res;} Queue数据结构介绍在Java中Queue是和List、Map同等级别的接口，LinkedList实现了Queue接口，该接口中的主要函数有： 容量不够或队列为空时不会抛异常：offer（添加队尾元素）、peek（访问队头元素）、poll（访问队头元素并移除） 容量不够或队列为空时抛异常：add、element（访问队列元素）、remove（访问队头元素并移除 9. 二叉搜索树的后序遍历序列题目描述：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同 概念：二叉搜索树，它是一棵空树，或者是具有下列性质的二叉树，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树 题解：首先判断是否为空；若不为空，最后一个元素是根结点，遍历第一个元素到根节点前面一个元素，若第i个元素大于根结点的值，则开始到i-1为左子树，判断i到最后一个元素是否符合右子树的定义，遍历其值是否大于根结点。 1234567891011121314151617181920public boolean VerifySquenceOfBST(int [] sequence) { if(sequence.length == 0) return false; if(sequence.length == 1) return true; return judge(sequence,0,sequence.length-1); }public boolean judge(int[]sequence, int start, int root){ // 当某个字数只有一个结点的时候 start 会大于 root，见下 if(start &gt;= root)return true; int i = start; while(i&lt;root &amp;&amp; sequence[i]&lt;sequence[root]) i++; for(int j = i;j&lt;root; j++){ if(sequence[j] &lt; sequence[root]){ return false; } } // 若某个子树只有一个节点，i=start，则i-1&lt;start return judge(sequence,start,i-1)&amp;&amp;judge(sequence,i,root-1);} 10. 二叉树中和为某一值的路径题目描述：输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 题解：递归先序遍历树，对某个节点，若target值大于0，把节点加入路径，target值减去该节点；若该结点是叶子结点则比较当前路径和是否等于0。若target小于0，弹出结点，返回到父结点时，当前路径也应该回退一个结点 1234567891011121314151617private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();private ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) { if(root == null) return listAll; if(target &gt;= 0){ list.add(root.val); target -= root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) // 拷贝列表，直接添加会修改同一个引用 listAll.add(new ArrayList&lt;Integer&gt;(list)); FindPath(root.left, target); FindPath(root.right, target); } // 栈回退，不需要加回target targrt在递归中就是他所在那层的值，下一层递归所改变的值不会递归到上一层 list.remove(list.size()-1); return listAll;}","link":"/2019/10/25/剑指offer/"},{"title":"快速幂原理及相关算法题","text":"快速幂计算 a 的 n 次方表示将 n 个 a 乘在一起，$a^n = aa …*a$（共n个a），当a，n太大的时候，这种方法不适用。已知公式：$$a^{b+c} = a^b·a^c,a^{2b}=a^b·a^b=(a^b)^2$$ 二进制取幂的想法就是将指数按照二进制表示分割成更小的任务,例如： $$3^{13} = 3^{(1101)_2} = 3^{2^3}·3^{2^2}·3^{2^0}$$ 因为n有$\\lfloor log_2 n \\rfloor + 1$ 个二进制位，因此我们知道了 $a^1,a^2,a^4,a^8,…,a^{2^{\\lfloor log_2 n \\rfloor}}$后，再计算$O(logn)$次乘法就可以计算出$a^n$，因此需要快速计算$a$的$2^k$次幂的序列，序列中（除第一个）任意一个元素就是其前一个元素的平方 $$3^1=3$$, $$3^2=(3^1)^2=9$$, $$3^4=(3^2)^2=81$$, $$3^8=(3^4)^2=6561$$ $$3^{13}=3^{2^3}·3^{2^2}·3^{2^0}=3^83^43^1$$ 快速幂公式总结如果把$n$写成二进制为 $(n_tn_{t-1}···n_1n_0)_2$，那么有： $$n = n_t2^t + n_{t-1}2^{t-1}+···+n_12^1 + n_02^0$$ 那么 $$a^n = a^{(n_t2^t + n_{t-1}2^{t-1}+···+n_12^1 + n_02^0)}=a^{n_t2^t} +a^{n_{t-1}2^{t-1}}+···+a^{n_12^1} + a^{n_02^0}$$ 原问题被转化成了形式相同的子问题的乘积，并且可以在常数时间内从$2^k$项推出$2^{k+1}$项。 时间复杂度 $O(logn)$，计算了$O(logn)$个$2^k$次幂的数，然后花费$O(logn)$的时间选择二进制为 1 对应的幂来相乘 代码实现1234567891011121314long long binpow(long long a, long long n) { // 0次幂 = 1 if (n == 0) return 1; long long res = 1; while(n &gt; 0){ // 转化为二进制对应位为 1 if((n&amp;&amp;1)==1) res*=a; // 计算2^k次幂，前面一个数的平方 a*=a; // n向后移1位 n&gt;&gt;=1; } return res;} 相关算法题给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 保证base和exponent不同时为0 首先先考虑所有的情况：然后对乘方的情况用快速幂计算 123456789101112131415161718public double Power(double base, int exponent) { int n = exponent; double res = 1; if(base == 0){ if(exponent &gt; 0) return 0; if(exponent &lt;= 0) throw new RuntimeException(\"error\"); } else{ if(exponent == 0)return 1; if(exponent &lt; 0) n = -exponent; } while(n&gt;0){ if((n&amp;1)==1) res *= base; base*=base; n&gt;&gt;=1; } return exponent &gt; 0?res:(1/res);} 1234import java.lang.Math;public double Power(double base, int exponent) { return Math.pow(base, exponent);}","link":"/2019/10/25/快速幂/"},{"title":"斐波那契数列多种解法","text":"斐波那契数列的标准公式为：$F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)$ 斐波那契数列讲解1. 递归法123456public int Fibonacci(int n) { if(n &lt;= 1){ return n; } return Fibonacci(n-1) + Fibonacci(n-2);} 时间复杂度：$O(2^n)$ 空间复杂度：$O(1)$ 2. 优化递归（利用数组存储）递归会重复计算，利用数组存储 123456789public int Fibonacci(int n) { int fb[] = new int[40]; fb[0] = 0; fb[1] = 1; for(int i=2;i&lt;=n;i++){ fb[i] = fb[i-1] + fb[i-2]; } return ans[n];} 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 3. 优化存储（减少存储空间）每次只用到最近两个数，因此可以只存储最近的两个数 sum 存储第 n 项的值 pre​ 存储第 n-2 项的值 next​ 存储第 n-1 项的值 1234567891011121314public int Fibonacci(int n) { if(n &lt;= 1){ return n; } int pre = 0; int next = 1; int sum = 0; for(int i = 2; i&lt;=n; i++){ sum = pre + next; pre = next; next = sum; } return sum;} 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 4. 继续优化存储空间我们发现sum只是在计算第n项的时候使用，其实可以利用sum存储第n-1项 123456789101112public int Fibonacci(int n) { if(n &lt;= 1){ return n; } int pre = 0; int sum = 1; for(int i = 2; i&lt;=n; i++){ sum = sum + pre; pre = sum - pre; } return sum;} 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 5. 根据递推公式构造系数矩阵用于快速幂（竞赛中经常用到）参考： https://blog.csdn.net/u012061345/article/details/52224623#commentBox 123456789101112131415161718192021222324252627282930313233343536373839404142434445链接：https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3?answerType=1&amp;f=discussion来源：牛客网class Mat { // 矩阵对象 int n = 2; int m[][] = new int[n][n]; public Mat mul(Mat a) { // 矩阵乘法 Mat b = new Mat(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; n; k++) b.m[i][j] += this.m[i][k] * a.m[k][j]; } return b; }} public class Solution { public static int Fibonacci(int n) { if(n==0){ return 0; } Mat ans = new Mat(); for (int i = 0; i &lt; ans.n; i++) { //单位矩阵初始化 ans.m[i][i] = 1; } Mat base = new Mat(); base.m[0][0] = base.m[0][1] = base.m[1][0] = 1; // base矩阵初始化 base.m[1][1] = 0; n -= 1; while (n &gt; 0) { // 快速幂：求base矩阵的n-1次方 if ((n &amp; 1) != 0) { ans = ans.mul(base); } n &gt;&gt;= 1; base = base.mul(base); } return ans.m[0][0]; }} 变种题目1. 青蛙跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果） 分析：青蛙跳上1级台阶有一种方法；青蛙跳上2级台阶有2种方法，一次跳2或两次跳1； 当青蛙跳n级台阶(n&gt;2)，有 $f(n)$ 种跳法那么考虑最后一步 如果跳两级台阶，那么第n-2级台阶有 $f(n-2)$ 种跳法 如果跳一级台阶，那么第n-1级台阶有 $f(n-1)$ 种跳法 因此 $f(n) = f(n-1) + f(n-2)$ 1234567891011121314public int JumpFloor(int target) { if(target &lt;= 2){ return target; } int sum = 0; int one = 1; int two = 2; for(int i = 3; i &lt;= target; i++){ sum = one + two; one = two; two = sum; } return sum;} 2. 青蛙变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 分析：青蛙跳上1级台阶有一种方法；青蛙跳上2级台阶有2种方法，一次跳2或两次跳1； 当青蛙跳n级台阶(n&gt;2)，有 $f(n)$ 种跳法那么考虑最后一步 如果跳一级台阶，那么第n-1级台阶有 $f(n-1)$ 种跳法 如果跳两级台阶，那么第n-2级台阶有 $f(n-2)$ 种跳法 …… 如果跳n-1级台阶，那么第1种有 $f(1)$ 种跳法 如果跳n级台阶，那么有 1 种跳法 因此 $f(n) = f(n-1) + f(n-2) + … + f(1) + 1$， 优化形式可以得出 $f(n) = 2*f(n-1)$， 最终 $f(n) = 2^{(n-1)}$ 1234567import java.lang.Math;public int JumpFloorII(int target) { if(target &lt;= 0){ return target; } return (int)Math.pow(2,target-1);} 使用移位操作符： 1int a=1; return a&lt;&lt;(number-1); 谁快？：我的运行结果显示 使用Math.pow 耗时 22ms，占用内存 9228K；使用移位操作符耗时 25ms，占用内存 9480K 3. 矩形覆盖可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 思考：涂掉最后一级矩形的时候，是用什么方式完成的？ 当n=1时 只能横着覆盖，一种 当n=2时 可以横着覆盖或竖着覆盖，两种 当n=3时 第三级横着覆盖，用了一级，剩n=2，有两种 第三级竖着覆盖，用了两级，剩n=1，有一种 共三种 当n=4时 第四级横着覆盖，用了一级，剩n=3，有三种 第四级竖着覆盖，用了两级，剩n=2，有两种 共五种 当n=n时 第n级横着覆盖，用了一级，剩n-1，有 $f(n-1)$ 种 第n级竖着覆盖，用了两级，剩n-2，有 $f(n-2)$ 种 共 $f(n-1)+f(n-2)$ 种 所以涂掉最后一级矩阵的时候，可以选择使用横向完成，也可以使用竖向完成，横向涂剩下 n-1 阶，竖向涂剩下 n-2 阶。关注 n - 1 与 n - 2 时的涂法有几种，这就是斐波那契数列","link":"/2019/10/24/斐波那契数列多种解法/"},{"title":"补码反码原理解析及算法应用","text":"计算机要使用一定的编码方式存储一个数。 原码，反码，补码是机器存储一个具体数字的编码方式。 1. 原码原码就是符号位加上真值的绝对值，即用第一位表示符号位，其余位表示值，例如8位二进制： $[+1]= [00000001]~{原码} $ $[-1] = [10000001]~{原码}$ 因为第一位是符号位，所以8位二进制数的取值范围$[11111111 ， 011111111]$ ，即$[-127 ， 127]$。 原码是最容易理解的方式 2. 反码正数的反码是其本身；负数的反码在其原码的基础上，符号位不变，其余各位取反 $[+1]= [00000001]{原码} = [00000001]{反码}$ $[-1] = [10000001]{原码} = [11111110]{反码}$ 3. 补码正数的补码是其本身；负数的补码在其原码的基础上，符号位不变，其余各位取反，最后+1，即反码+1 $[+1]= [00000001]{原码} = [00000001]{反码} = [00000001]~{补码}$ $[-1] = [10000001]{原码} = [11111110]{反码}=[11111111]~{补码}$ 负数的反码通常需要转换成原码再计算其数值 4. 使用原码、反码、补码的原因目的：统一计算方式，符号位参与运算，简化计算机电路设计 原理：借鉴数论中 同余理论，反码与补码计算过程一样，补码可以解决0符号的问题并表示-128。 $-128 = [10000000]补 = [11111111]反 = [10000000]~原$ 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法。 运算法则减去一个正数等于加上一个负数，即: 1-1 = 1 + (-1) = 0，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。 计算十进制的表达式: 1-1=0 $1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]~原 = -2$ 如果用原码表示， 让符号位也参与计算， 显然对于减法来说， 结果是不正确的 为了解决原码做减法的问题，出现了反码； $1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0$ 发现用反码计算减法， 结果的真值部分是正确的。 而唯一的问题其实就出现在”0”这个特殊的数值上。 虽然人们理解上+0和-0是一样的， 但是0带符号是没有任何意义的。 而且会有[0000 0000]原和[1000 0000]原两个编码表示0。 于是使用补码，解决0的符号问题以及两个编码的问题： $1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原$ 这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128: $(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]~补$ -1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示$[1000 0000]补$算出来的原码是$[0000 0000]原$, 这是不正确的) 使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]. 因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是:$ [-2^{31}, 2^{31}-1]$ 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值. 5. 算法题：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。题目说到：负数在计算机中用补码表示 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011。我们发现减1的结果是把最右边的一个1开始的所有位都取反了。 $12-1 = [00001100]补+[11111111]补= [00001011]~补 = 11$ $12 &amp;11 = [00001100]补 &amp; [00001011]补 = [00001000]~补$ 使得最右边一个1变成0； $-12-1 = [11110100]补 + [11111111]补 = [11110011]~补= -13$ $(-12)&amp;(-13) = [11110100]补 &amp; [11110011]补 = [11110000]~补$ 使最右边1个1变成0 这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。","link":"/2019/10/25/补码反码原理/"},{"title":"MindAlpha 调研报告","text":"MindAlpha 机器学习平台是汇量科技（Mobvista）推出的全流程一站式机器学习平台。MindAlpha平台功能覆盖了广告、搜索、推荐等互联网核心业务对机器学习平台的各方面需求，包括大规模实时数据流和高效特征工程框架，百亿特征、千亿样本的大规模复杂模型训练框架，以及海量请求的高性能低延迟的在线预测框架。 MindAlpha 调研报告MindAlpha 平台链接 一、 \b背景MindAlpha 机器学习平台是汇量科技（Mobvista）推出的全流程一站式机器学习平台。Mobvista是全球领先的移动营销平台，目前已建立起海外覆盖FB/Google之外超3万个独立媒体的流量矩阵，广告+统计SDK覆盖3.3亿日独立设备；涉及从移动应用安装前到安装后全生命周期用户行为的海量数据覆盖。目前变现收入55%以上来自海外超过60个国家，海外广告主资源丰富，已规模化盈利。MindAlpha平台功能覆盖了广告、搜索、推荐等互联网核心业务对机器学习平台的各方面需求，包括大规模实时数据流和高效特征工程框架，百亿特征、千亿样本的大规模复杂模型训练框架，以及海量请求的高性能低延迟的在线预测框架。 二、 平台简介1. MindAlpha 计算平台架构MindAlpha平台构建于超大规模分布式计算平台之上，包含了与开源生态兼容的云端部署的分布式集群，通过自主研发的多种计算、服务框架，构建了大数据计算服务、分布式机器学习服务以及在线实时预测、评估以及实时数据服务。整体的计算平台架构如下图所示： \b图1 MindAlpha 计算平台架构图 1.1 数据仓库介绍 数据仓库的特点 1)、数据仓库是面向主题的；操作型数据库的数据组织面向事务处理任务，而数据仓库中的数据是按照一定的主题域进行组织。主题是指用户使用数据仓库进行决策时所关心的重点方面，一个主题通常与多个操作型信息系统相关。 2)、数据仓库是集成的；数据仓库的数据有来自于分散的操作型数据，将所需数据从原来的数据中抽取出来，进行加工与集成，统一与综合之后才能进入数据仓库；数据仓库中的数据是在对原有分散的数据库数据抽取、清理的基础上经过系统加工、汇总和整理得到的，必须消除源数据中的不一致性，以保证数据仓库内的信息是关于整个企业的一致的全局信息。数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一旦某个数据进入数据仓库以后，一般情况下将被长期保留，也就是数据仓库中一般有大量的查询操作，但修改和删除操作很少，通常只需要定期的加载、刷新。数据仓库中的数据通常包含历史信息，系统记录了企业从过去某一时点(如开始应用数据仓库的时点)到当前的各个阶段的信息，通过这些信息，可以对企业的发展历程和未来趋势做出定量分析和预测。 3)、数据仓库是不可更新的，数据仓库主要是为决策分析提供数据，所涉及的操作主要是数据的查询；数据仓库是随时间而变化的，传统的关系数据库系统比较适合处理格式化的数据，能够较好的满足商业商务处理的需求。稳定的数据以只读格式保存，且不随时间改变。 4)、效率足够高。数据仓库的分析数据一般分为日、周、月、季、年等，可以看出，日为周期的数据要求的效率最高，要求24小时甚至12小时内，客户能看到昨天的数据分析。由于有的企业每日的数据量很大，设计不好的数据仓库经常会出问题，延迟1-3日才能给出数据，显然不行的。 5)、数据质量。数据仓库所提供的各种信息，肯定要准确的数据，但由于数据仓库流程通常分为多个步骤，包括数据清洗，装载，查询，展现等等，复杂的架构会更多层次，那么由于数据源有脏数据或者代码不严谨，都可以导致数据失真，客户看到错误的信息就可能导致分析出错误的决策，造成损失，而不是效益。 6)、扩展性。之所以有的大型数据仓库系统架构设计复杂，是因为考虑到了未来3-5年的扩展性，这样的话，未来不用太快花钱去重建数据仓库系统，就能很稳定运行。主要体现在数据建模的合理性，数据仓库方案中多出一些中间层，使海量数据流有足够的缓冲，不至于数据量大很多，就运行不起来了。 1.2 DMP（数据管理平台）DMP(Data Management Platform)数据管理平台，是把分散的多方数据进行整合纳入统一的技术平台，并对这些数据进行标准化和细分，让用户可以把这些细分结果推向现有的互动营销环境里的平台。 作用 能快速查询、反馈和快速呈现结果 能帮助客户更快进入到市场周期中 能促成企业用户和合作伙伴之间的合作 能深入的预测分析并作出反应 能带来各方面的竞争优势 能降低信息获取及人力成本 类型 结构化的数据，比如Oracle数据库数据等； 非结构化的数据，比如各种文件、图像、音频等数据，等等。 结构化数据（即数据库数据）在当今的信息系统中占据最核心、最重要的位置。结构化数据从产生―使用―消亡这样一个完整过程的管理，就是数据生命周期管理。 核心元素包括： 数据整合及标准化能力：采用统一化的方式，将各方数据吸纳整合。 数据细分管理能力：创建出独一无二、有意义的客户细分，进行有效营销活动。 功能健全的数据标签：提供数据标签灵活性，便于营销活动的使用。 自助式的用户界面：基于网页web界面或其他集成方案直接获取数据工具，功能和几种形式报表和分析。 相关渠道环境的连接：跟相关渠道的集成，包含网站端、展示广告、电子邮件以及搜索和视频，让营销者能找到、定位和提供细分群体相关高度的营销信息。 2. MindAlpha具体的架构其中MindAlpha提供的一站式机器学习服务是整个计算平台最为核心的功能，MindAlpha具体的架构如下图所示： 图2 MindAlpha 具体架构图 2.1 实时特征工程参考链接：机器学习中的数据清洗与特征处理综述 1）特征获取 离线特征获取方案离线可以使用海量的数据，借助于分布式文件存储平台，例如HDFS等，使用例如MapReduce，Spark等处理工具来处理海量的数据等。 在线特征获取方案在线特征比较注重获取数据的延时，由于是在线服务，需要在非常短的时间内获取到相应的数据，对查找性能要求非常高，可以将数据存储在索引、kv存储等。而查找性能与数据的数据量会有矛盾，需要折衷处理，我们使用了特征分层获取方案，如图3所示：出于性能考虑。在粗排阶段，使用更基础的特征，数据直接建入索引。精排阶段，再使用一些个性化特征等。 图3 特征分层获取方案 2）数据清洗 离线清洗数据：离线清洗优点是方便评估新特征效果，缺点是实时性差，与线上实时环境有一定误差。对于实时特征难以训练得到恰当的权重。 在线清洗数据：在线清洗优点是实时性强，完全记录的线上实际数据，缺点是新特征加入需要一段时间做数据积累。 3）特征分类在分析完特征和标注的清洗方法之后，下面来具体介绍下特征的处理方法，先对特征进行分类，对于不同的特征应该有不同的处理方法。 根据不同的分类方法，可以将特征分为：Low level特征和High level特征；稳定特征与动态特征；二值特征、连续特征、枚举特征。 Low level特征和High level特征 Low level特征是较低级别的特征，主要是原始特征，不需要或者需要非常少的人工处理和干预，例如文本特征中的词向量特征，图像特征中的像素点，用户id，商品id等。Low level特征一般维度比较高，不能用过于复杂的模型。High level特征是经过较复杂的处理，结合部分业务逻辑或者规则、模型得到的特征，例如人工打分，模型打分等特征，可以用于较复杂的非线性模型。Low level 比较针对性，覆盖面小。长尾样本的预测值主要受high level特征影响。 高频样本的预测值主要受low level特征影响。 稳定特征与动态特征 稳定特征是变化频率(更新频率)较少的特征，例如评价平均分，团购单价格等，在较长的时间段内都不会发生变化。 动态特征是更新变化比较频繁的特征，有些甚至是实时计算得到的特征，例如距离特征，2小时销量等特征。或者叫做实时特征和非实时特征。 针对两类特征的不同可以针对性地设计特征存储和更新方式，例如对于稳定特征，可以建入索引，较长时间更新一次，如果做缓存的话，缓存的时间可以较长。对于动态特征，需要实时计算或者准实时地更新数据，如果做缓存的话，缓存过期时间需要设置的较短。 二值特征、连续特征、枚举特征 二值特征主要是 0/1 特征，即特征只取两种值：0或者1，例如用户id特征：目前的 id 是否是某个特定的 id，词向量特征：某个特定的词是否在文章中出现等等。 连续值特征是取值为有理数的特征，特征取值个数不定，例如距离特征，特征取值为是0~正无穷。 枚举值特征主要是特征有固定个数个可能值，例如今天周几，只有 7 个可能值：周一，周二，…，周日。 在实际的使用中，我们可能对不同类型的特征进行转换，例如将枚举特征或者连续特征处理为二值特征。枚举特征处理为二值特征技巧：将枚举特征映射为多个特征，每个特征对应一个特定枚举值，例如今天周几，可以把它转换成7个二元特征：今天是否是周一，今天是否是周二，…，今天是否是周日。连续值处理为二值特征方法：先将连续值离散化（后面会介绍如何离散化)，再将离散化后的特征切分为 N 个二元特征，每个特征代表是否在这个区间内。 4）特征的处理和分析在对特征进行分类后，下面介绍下对特征常用的处理方法。包括特征归一化，离散化，缺省值处理；特征降维方法；特征选择方法等。 特征归一化，离散化，缺省值处理（主要用于单个特征的处理） 归一化：不同的特征有不同的取值范围，在有些算法中，例如线性模型或者距离相关的模型像聚类模型、knn模型等，特征的取值范围会对最终的结果产生较大影响，例如二元特征的取值范围为[0，1]，而距离特征取值可能是[0，正无穷)，在实际使用中会对距离进行截断，例如[0，3000000]，但是这两个特征由于取值范围不一致导致了模型可能会更偏向于取值范围较大的特征，为了平衡取值范围不一致的特征，需要对特征进行归一化处理，将特征取值归一化到［0，1］区间。常用的归一化方法包括1.函数归一化，通过映射函数将特征取值映射到［0，1］区间，例如最大最小值归一化方法，是一种线性的映射。还有通过非线性函数的映射，例如log函数等。2.分维度归一化，可以使用最大最小归一化方法，但是最大最小值选取的是所属类别的最大最小值，即使用的是局部最大最小值，不是全局的最大最小值。3.排序归一化，不管原来的特征取值是什么样的，将特征按大小排序，根据特征所对应的序给予一个新的值。 离散化：在上面介绍过连续值的取值空间可能是无穷的，为了便于表示和在模型中处理，需要对连续值特征进行离散化处理。常用的离散化方法包括等值划分和等量划分。等值划分是将特征按照值域进行均分，每一段内的取值等同处理。例如某个特征的取值范围为[0，10]，我们可以将其划分为10段，[0，1)，[1，2)，…，[9，10)。等量划分是根据样本总数进行均分，每段等量个样本划分为1段。例如距离特征，取值范围［0，3000000］，现在需要切分成10段，如果按照等比例划分的话，会发现绝大部分样本都在第1段中。使用等量划分就会避免这种问题，最终可能的切分是[0，100)，[100，300)，[300，500)，..，[10000，3000000]，前面的区间划分比较密，后面的比较稀疏。 缺省值处理：有些特征可能因为无法采样或者没有观测值而缺失，例如距离特征，用户可能禁止获取地理位置或者获取地理位置失败，此时需要对这些特征做特殊的处理，赋予一个缺省值。缺省值如何赋予，也有很多种方法。例如单独表示，众数，平均值等。 特征降维主要是出于如下考虑： 特征维数越高，模型越容易过拟合，此时更复杂的模型就不好用。 相互独立的特征维数越高，在模型不变的情况下，在测试集上达到相同的效果表现所需要的训练样本的数目就越大。 特征数量增加带来的训练、测试以及存储的开销都会增大。 在某些模型中，例如基于距离计算的模型KMeans，KNN等模型，在进行距离计算时，维度过高会影响精度和性能。 可视化分析的需要。在低维的情况下，例如二维，三维，我们可以把数据绘制出来，可视化地看到数据。当维度增高时，就难以绘制出来了。 特征降维常用的算法有PCA，LDA等。特征降维的目标是将高维空间中的数据集映射到低维空间数据，同时尽可能少地丢失信息，或者降维后的数据点尽可能地容易被区分 PCA算法通过协方差矩阵的特征值分解能够得到数据的主成分，以二维特征为例，两个特征之间可能存在线性关系（例如运动的时速和秒速度），这样就造成了第二维信息是冗余的。PCA的目标是发现这种特征之间的线性关系，并去除。 LDA算法考虑label，降维后的数据点尽可能地容易被区分 特征选择特征选择的目标是寻找最优特征子集。特征选择能剔除不相关(irrelevant)或冗余(redundant )的特征，从而达到减少特征个数，提高模型精确度，减少运行时间的目的。另一方面，选取出真正相关的特征简化模型，协助理解数据产生的过程。特征选择的一般过程如图 4 所示： 图4 特征选择过程图 主要分为产生过程，评估过程，停止条件和验证过程。 特征选择-产生过程和生成特征子集方法 完全搜索(Complete)： 广度优先搜索( Breadth First Search )：广度优先遍历特征子空间。枚举所有组合，穷举搜索，实用性不高。 分支限界搜索( Branch and Bound )：穷举基础上加入分支限界。例如：剪掉某些不可能搜索出比当前最优解更优的分支。 其他，如定向搜索 (Beam Search )，最优优先搜索 ( Best First Search )等 启发式搜索(Heuristic) 序列前向选择( SFS ， Sequential Forward Selection )：从空集开始，每次加入一个选最优。 序列后向选择( SBS ， Sequential Backward Selection )：从全集开始，每次减少一个选最优。增L去R选择算法 ( LRS ， Plus-L Minus-R Selection )从空集开始，每次加入L个，减去R个，选最优（L&gt;R)或者从全集开始，每次减去R个，增加L个，选最优(L&lt;R)。 其他如双向搜索( BDS ， Bidirectional Search )，序列浮动选择( Sequential Floating Selection )等 随机搜索(Random) 随机产生序列选择算法(RGSS， Random Generation plus Sequential Selection)：随机产生一个特征子集，然后在该子集上执行SFS与SBS算法。 模拟退火算法( SA， Simulated Annealing )以一定的概率来接受一个比当前解要差的解，而且这个概率随着时间推移逐渐降低 遗传算法( GA， Genetic Algorithms ):通过交叉、突变等操作繁殖出下一代特征子集，并且评分越高的特征子集被选中参加繁殖的概率越高。 MindAlpha平台提供的一站式机器学习服务完整覆盖了：数据流接入、特征生成、模型训练、线上预测、在线评估、在线学习的全周期流程。MindAlpha集成了多个大规模离散特征在线学习算法，经历了每天百亿PV、十亿UV量级的实际业务考验，开箱即用。同时也能够支持快速算法原型的开发验证，以及模型生产部署的无缝对接。 MindAlpha平台采用了Cloud Native设计，通过强大的资源弹性伸缩功能保证了大规模的计算能力和成本的平衡，能够方便企业进行公、私有云的快速弹性部署，充分体现了AI as a Service的强大服务能力。下面分别介绍MindAlpha一站式机器学习平台的核心重点模块。 2.2 Cloud Nativa 设计的介绍参考文章 简介： 云原生（Cloud Native）的概念，由来自Pivotal的MattStine于2013年首次提出，被一直延续使用至今。这个概念是Matt Stine根据其多年的架构和咨询经验总结出来的一个思想集合，并得到了社区的不断完善，内容非常多，包括DevOps、持续交付（Continuous Delivery）、微服务（MicroServices）、敏捷基础设施（Agile Infrastructure）和12要素（TheTwelve-Factor App）等几大主题，不但包括根据业务能力对公司进行文化、组织架构的重组与建设，也包括方法论与原则，还有具体的操作工具。采用基于云原生的技术和管理方法，可以更好地把业务生于“云”或迁移到云平台，从而享受“云”的高效和持续的服务能力。 顾名思义，云原生是面向“云”而设计的应用，因此技术部分依赖于在传统云计算的3层概念（基础设施即服务（IaaS）、平台即服务（PaaS）和软件即服务（SaaS）），例如，敏捷的不可变基础设施交付类似于IaaS，用来提供计算网络存储等基础资源，这些资源是可编程且不可变的，直接通过API可以对外提供服务；有些应用通过PaaS服务本来就能组合成不同的业务能力，不一定需要从头开始建设；还有一些软件只需要“云”的资源就能直接运行起来为云用户提供服务，即SaaS能力，用户直接面对的就是原生的应用。 应用基于云服务进行架构设计，对技术人员的要求更高，除了对业务场景的考虑外，对隔离故障、容错、自动恢复等非功能需求会考虑更多。借助云服务提供的能力也能实现更优雅的设计，比如弹性资源的需求、跨机房的高可用、11个9（99.999999999%）的数据可靠性等特性，基本是云计算服务本身就提供的能力，开发者直接选择对应的服务即可，一般不需要过多考虑本身机房的问题。如果架构设计本身又能支持多云的设计，可用性会进一步提高，比如Netflix能处理在AWS的某个机房无法正常工作的情况，还能为用户提供服务，这就是“云”带来的魔力，当然，云也会带来更多的隔离等问题。如图 5 所示，目前业界公认的云原生主要包括以下几个层面的内容。 图5 Cloud Native 的内容 敏捷基础设施正如通过业务代码能够实现产品需求、通过版本化的管理能够保证业务的快速变更，基于云计算的开发模式也要考虑如何保证基础资源的提供能够根据代码自动实现需求，并实现记录变更，保证环境的一致性。使用软件工程中的原则、实践和工具来提供基础资源的生命周期管理，这意味着工作人员可以更频繁地构建更强可控或更稳定的基础设施，开发人员可以随时拉取一套基础设施来服务于开发、测试、联调和灰度上线等需求。当然，同时要求业务开发具有较好的架构设计，不需要依赖本地数据进行持久化，所有的资源都是可以随时拉起，随时释放，同时以API的方式提供弹性、按需的计算、存储能力。技术人员部署服务器、管理服务器模板、更新服务器和定义基础设施的模式都是通过代码来完成的，并且是自动化的，不能通过手工安装或克隆的方式来管理服务器资源，运维人员和开发人员一起以资源配置的应用代码为中心，不再是一台台机器。基础设施通过代码来进行更改、测试，在每次变更后执行测试的自动化流程中，确保能维护稳定的基础设施服务。此外，基础设施的范围也会更加广泛，不仅包括机器，还包括不同的机柜或交换机、同城多机房、异地多机房等，这些内容也会在后续章节中逐一进行部分讨论。 持续交付为了满足业务需求频繁变动，通过快速迭代，产品能做到随时都能发布的能力，是一系列的开发实践方法。它分为持续集成、持续部署、持续发布等阶段，用来确保从需求的提出到设计开发和测试，再到让代码快速、安全地部署到产品环境中。持续集成是指每当开发人员提交了一次改动，就立刻进行构建、自动化测试，确保业务应用和服务能符合预期，从而可以确定新代码和原有代码能否正确地集成在一起。持续交付是软件发布的能力，在持续集成完成之后，能够提供到预发布之类系统上，达到生产环境的条件，持续部署是指使用完全的自动化过程来把每个变更自动提交到测试环境中，然后将应用安全地部署到产品环境中，打通开发、测试、生产的各个环节，自动持续、增量地交付产品，也是大量产品追求的最终目的，当然，在实际运行的过程中，有些产品会增加灰度发布等环境。总之，它更多是代表一种软件交付的能力，过程示例请参考图6。图6 持续交付流程 DevOpsDevOps如果从字面上来理解只是Dev（开发人员）+Ops（运维人员），实际上，它是一组过程、方法与系统的统称，其概念从2009年首次提出发展到现在，内容也非常丰富，有理论也有实践，包括组织文化、自动化、精益、反馈和分享等不同方面。首先，组织架构、企业文化与理念等，需要自上而下设计，用于促进开发部门、运维部门和质量保障部门之间的沟通、协作与整合，简单而言组织形式类似于系统分层设计。其次，自动化是指所有的操作都不需要人工参与，全部依赖系统自动完成，比如上述的持续交付过程必须自动化才有可能完成快速迭代。再次，DevOps的出现是由于软件行业日益清晰地认识到，为了按时交付软件产品和服务，开发部门和运维部门必须紧密合作。总之，如图 7 所示，DevOps强调的是高效组织团队之间如何通过自动化的工具协作和沟通来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件。图7 DevOps强调组织的沟通与协作 微服务随着企业的业务发展，传统业务架构面临着很多问题。其一，单体架构在需求越来越多的时候无法满足其变更要求，开发人员对大量代码的变更会越来越困难，同时也无法很好地评估风险，所以迭代速度慢；其二，系统经常会因为某处业务的瓶颈导致整个业务瘫痪，架构无法扩展，木桶效应严重，无法满足业务的可用性要求；最后，整体组织效率低下，无法很好地利用资源，存在大量的浪费。因此，组织迫切需要进行变革。随着大量开源技术的成熟和云计算的发展，服务化的改造应运而生，不同的架构设计风格随之涌现，最有代表性的是Netflix公司，它是国外最早基于云进行服务化架构改造的公司，2008年因为全站瘫痪被迫停业3天后，它痛下决心改造，经过将近10年的努力，实现了从单架构到微服务全球化的变迁，满足了业务的千倍增长（如图 8 所示），并产生了一系列的最佳实践。图8 Netflix 微服务化支撑业务千倍增长 随着微服务化架构的优势展现和快速发展，2013年，MartinFlower对微服务概念进行了比较系统的理论阐述，总结了相关的技术特征。首先，微服务是一种架构风格，也是一种服务；其次，微服务的颗粒比较小，一个大型复杂软件应用由多个微服务组成，比如Netflix目前由500多个的微服务组成；最后，它采用UNIX设计的哲学，每种服务只做一件事，是一种松耦合的能够被独立开发和部署的无状态化服务（独立扩展、升级和可替换）。微服务架构如图 9 所示。 图 9 微服务架构示例 由微服务的定义分析可知，一个微服务基本是一个能独立发布的应用服务，因此可以作为独立组件升级、灰度或复用等，对整个大应用的影响也较小，每个服务可以由专门的组织来单独完成，依赖方只要定好输入和输出口即可完全开发，甚至整个团队的组织架构也会更精简，因此沟通成本低、效率高。根据业务的需求，不同的服务可以根据业务特性进行不同的技术选型，是计算密集型还是I/O密集型应用都可以依赖不同的语言编程模型，各团队可以根据本身的特色独自运作。服务在压力较大时，也可以有更多容错或限流服务。 微服务架构确实有很多吸引人的地方，然而它的引入也是有成本的，它并不是银弹，使用它会引入更多技术挑战，比如性能延迟、分布式事务、集成测试、故障诊断等方面，企业需要根据业务的不同的阶段进行合理的引入，不能完全为了微服务而“微服务”，本书第5章也会对如何解决这些问题提供对应不同方案的权衡。 “12”要素“12要素”英文全称是The Twelve-Factor App，最初由Heroku的工程师整理起步，是集体贡献总结的智慧，如图1-9所示。根据基于云的软件开发模式，12要素比较贴切地描述了软件应用的原型，并诠释了使用原生云应用架构的原因。比如，一个优雅的互联网应用在设计过程中，需要遵循的一些基本原则和云原生有异曲同工之处。通过强化详细配置和规范，类似Rails的基于“约定优于配置”（convention over configuration）的原则，特别在大规模的软件生产实践中，这些约定非常重要，从无状态共享到水平扩展的过程，从松耦合架构关系到部署环境。基于12要素的上下文关联，软件生产就变成了一个个单一的部署单元；多个联合部署的单元组成一个应用，多个应用之间的关系就可以组成一个复杂的分布式系统应用。 图 10 “ 12 “要素下面简要介绍图1-9中的这些原则。 基准代码每一个部署的应用都在版本控制代码库中被追踪。在多个部署环境中，会有多种部署实例，单个应用只有一份代码库，多份部署相当于运行了该应用的多个实例，比如开发环境一个实例，测试环境、生产环境都有一个实例。实际上，在云计算架构中，所有的基础设施都是代码配置，即Infrastructure as Code（IaC），整个应用通过配置文件就可以编排出来，而不再需要手工的干预，做到基础服务也是可以追踪的。 依赖应用程序不会隐式依赖系统级的类库，通过依赖清单声明所有依赖项，通过依赖隔离工具确保程序不会调用系统中存在，但清单中未声明依赖项，并统一应用到生产和开发环境。比如通过合适的工具（例如Maven、Bundler、NPM），应用可以很清晰地对部署环境公开和隔绝依赖性，而不是模糊地对部署环境产生依赖性。在容器应用中，所有应用的依赖和安装都是通过DockerFile来完成声明的，通过配置能明确把依赖关系，包括版本都明确地图形化展示出来，不存在黑盒。 配置环境变量是一种清楚、容易理解和标准化的配置方法，将应用的配置存储于环境变量中，保证配置排除在代码之外，或者其他可能在部署环境（例如研发、展示、生产）之间区别的任何代码，可以通过操作系统级的环境变量来注入。实例根据不同的环境配置运行在不同的环境中，此外，实现配置即代码，在云环境中，无论是统一的配置中心还是分布式的配置中心都有好的实践方式，比如Docker的环境变量使用。 后端服务不用区别对待本地或第三方服务，统一把依赖的后端作为一种服务来对待，例如数据库或者消息代理，作为附加资源，同等地在各种环境中被消耗。比如在云架构的基础服务中，计算、网络、存储资源都可以看作是一种服务去对待使用即可，不用区分是远程还是本地的。 构建、发布、运行应用严格区分构建、发布、运行这3个阶段。3个阶段是严格分开的，一个阶段对应做一件事情，每个阶段有很明确的实现功能。云原生应用的构建流程可以把发布配置挪到开发阶段，包括实际的代码构建和运行应用所需的生产环境配置。在云原生应用中，基于容器的Build-Ship-Run和这3个阶段完全吻合，也是Docker对本原则的最佳实践。 进程进程必须无状态且无共享，即云应用以一个或多个无状态不共享的程序运行。任何必要状态都被服务化到后端服务中（缓存、对象存储等）。所有的应用在设计时就认为随时随地会失败，面向失败而设计，因此进程可能会被随时拉起或消失，特别是在弹性扩容的阶段。 端口绑定不依赖于任何网络服务器就可以创建一个面向网络的服务，每个应用的功能都很齐全，通过端口绑定对外提供所有服务，比如Web应用通过端口绑定（Port binding）来提供服务，并监听发送至该端口的请求（包括HTTP）。在容器应用中，应用统一通过暴露端口来服务，尽量避免通过本地文件或进程来通信，每种服务通过服务发现而服务。 并发进程可以看作一等公民，并发性即可以依靠水平扩展应用程序来实现，通过进程模型进行扩展，并且具备无共享、水平分区的特性。在互联网的服务中，业务的爆发性随时可能发生，因此不太可能通过硬件扩容来随时提供扩容服务，需要依赖横向扩展能力进行扩容。 易处理所有应用的架构设计都需要支持能随时销毁的特点，和状态的无关性保持一致，允许系统快速弹性扩展、改变部署及故障恢复等。在云环境中，由于业务的高低峰值经常需要能实现快速灵活、弹性的伸缩应用，以及不可控的硬件因素等，应用可能随时会发生故障，因此应用在架构设计上需要尽可能无状态，应用能随时随地拉起，也能随时随地销毁，同时保证进程最小启动时间和架构的可弃性，也可以提供更敏捷的发布及扩展过程。 环境等价必须缩小本地与线上差异，确保环境的一致性，保持研发、测试和生产环境尽可能相似，这样可以提供应用的持续交付和部署服务。在容器化应用中，通过文件构建的环境运行能做到版本化，因此保证各个不同环境的差异性，同时还能大大减少环境不同带来的排错等成本沟通问题。 日志每一个运行的进程都会直接标准输出（stdout）和错误输出（stderr）事件流，还可以将日志当作事件流作为数据源，通过集中服务，执行环境收集、聚合、索引和分析这些事件。日志是系统运行状态的部分体现，无论在系统诊断、业务跟踪还是后续大数据服务的必要条件中，Docker提供标准的日志服务，用户可以根据需求做自定义的插件开发来处理日志。 管理进程管理或维护应用的运行状态是软件维护的基础部分，比如数据库迁移、健康检查、安全巡检等，在与应用长期运行的程序相同环境中，作为一次性程序运行。在应用架构模式中，比如Kubernetes里面的Pod资源或者dockerexec，可以随着其他的应用程序一起发布或在出现异常诊断时能通过相关的程序去管理其状态。云原生的内容非常广泛，目前没有系统的说明和完整的定义，上文介绍了云原生应用的基础组件和相关特点，可能读者对云原生应用的逻辑还存在一些困惑。为了更清楚地进行说明，我们总结了其依赖关系，如图 11 所示。图 11 云原生内容的依赖关系首先，为了抓住商业机会，业务需要快速迭代，不断试错，因此，企业需要依赖拥有持续交付的能力，这些不仅包括技术需求还包括产品的需求，如何能拥有持续交付的能力，大而全的架构因为效率低下，显然是不合适的。于是演变出微服务架构来满足需求，通过把系统划分出一个个独立的个体，每个个体服务的设计依赖需要通过12要素的原则来规范完成。同样，如果系统被分成了几十个甚至几百个服务组件，则需要借助DevOps才能很好地满足业务协作和发布等流程。最后，DevOps的有效实施需要依赖一定的土壤，即敏捷的基础设施服务，现实只有云计算的模式才能满足整体要求。通过上述梳理，我们总结出面向云原生应用的3个不同层次的特点： 1）高可用设计（Design for Availability），依据应用业务需求，高可用分为不同级别，比如不同区域、不同机房（跨城或同城）、不同机柜、不同服务器和不同进程的高可用，云原生应用应该根据业务的可用性要求设计不同级别的架构支持。2）可扩展设计（Design for Scale），所有应用的设计是无状态的，使得业务天生具有扩展性，在业务流量高峰和低峰时期，依赖云的特性自动弹性扩容，满足业务需求。3）快速失败设计（Design for Failure），即包括系统间依赖的调用随时可能会失败，也包括硬件基础设施服务随时可能宕机，还有后端有状态服务的系统能力可能有瓶颈，总之在发生异常时能够快速失败，然后快速恢复，以保证业务永远在线，不能让业务半死不活地僵持着。 通过上面的基本描述及云原生应用的组成或特点，随着互联网业务的架构不断演进，从单体应用到分布式应用，甚至微服务架构应用中，12要素较好地为构建互联网化应用提供了统一的方法论和标准化，具有强大的生命力，每一条原则都是应用开发的珠玑。当然，在实践过程中，每一个原则也不是一成不变的，随着新的理念和技术出现，原有的因素会得到延伸和发展，会出现新的原则和应用，这套理论也适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序，因此也作为云原生架构应用的基本指导原则之一。 4. 大规模高效的数据流和特征工程框架数据流和特征工程是算法训练的基础。高效的数据回流能力保证了模型训练样本生成的时效性，百亿规模的特征工程生成能力保证了样本对真实问题空间的匹配程度，从而进一步保证模型的准确度。 MindAlpha平台的数据流特征工程主要有以下技术特点： 1）在线回流特征和离线特征相结合。MindAlpha平台支持大量不同类型的在线特征，包括用户的各类实时行为统计特征等。这部分特征在离线没有对应数据，通过排序服务将这批特征回流到离线平台。而另一部分是离线特征表，包括DMP平台提供的大量设备维度特征等。 2）大维度表抽取优化。在线上数据回流后，进行多个维度表特征抽取时，往往容易遇到的问题是离线维度表很大，而回流数据只需要取很小一部分。但是传统的MapReduce方法仍然需要扫描大维度表，导致Shuffle和Join过程非常耗时。我们通过创新地综合运用In Memory Hash和小表Broadcast等方式，使得特征抽取的流程大幅加快，能够在10分钟内完成十亿量级的日志表与百亿量级的特征表的join操作。 3）原始特征列式存储。算法模型的调优通常需要频繁实验不同的（原始）特征，但是不同的实验往往只有小部分特征不同。为每组实验都重新生成一份样本，会造成较大的空间浪费，同时生成多份样本也会带来较大的资源开销。我们设计了全新的列式存储方案，使得原始特征分为不同的列来存储，在训练时可以指定所需的特征列。这样所有不同的实验都可以共享同一份样本存储，只需要选择不同的特征列即可。通过这样的优化，使得小时级的样本生成只需要一份，同时回溯多天的历史数据补充特征也只需要增加相关的列即可。 5. 超大规模分布式训练框架通过数据流和特征工程之后，接下来进入到模型训练的环节。对于在线广告领域，特征规模、样本规模是算法效果提升的重要基础，对于近期比较领先的Entire Space Multitask Model (ESMM)的学习范式等，模型空间还会大幅膨胀。因此，一个能够支持超大规模特征和样本的分布式机器学习训练框架是AI平台的核心组成部分。我们的分布式机器学习训练框架采用了底层分布式框架和上层算法框架分离的架构，主要原因是不同的算法在优化迭代的模式上有很多区别，同时算法与业务、特征等也有一定的耦合。单纯引入TensorFlow等DL框架并不能满足多样化的算法开发需求。具体来说整体架构可以分为两层： 1）第一层是一个大规模的Parameter Server框架。从架构上看和经典的PS架构类似。不同点是我们提供了通用的批量KV存取功能，并能够方便上层灵活定制Server端的存储对象格式。PS架构的横向扩展性使得我们能够高效地支撑百亿特征规模和千亿样本规模。 2）第二层是算法框架和算法组件。在这一层，我们有针对广告业务专门设计的若干个大规模稀疏特征在线算法，也能够无缝对接MXNet、PyTorch等深度学习框架。通过这样的层次切分，不同算法实验也可以共享特征组合、离散化等公共模块，同时又能够深度定制自身的算法逻辑，提高了算法开发迭代的效率。 5.1 Parameter Server 介绍李沐的文章，对该框架的一些介绍 概念参数服务器是个编程框架，用于方便分布式并行程序的编写，其中重点是对大规模参数的分布式存储和协同的支持。工业界需要训练大型的机器学习模型，一些广泛使用的特定的模型在规模上的两个特点： 参数很大，超过单个机器的容纳能力（比如大型Logistic Regression和神经网络） 训练数据巨大，需要分布式并行提速（大数据） 这种需求下，当前类似MapReduce的框架并不能很好适合。因此需要自己实现分布式并行程序，其实在Hadoop出来之前，对于大规模数据的处理，都需要自己写分布式的程序（MPI）。 之后这方面的工作流程被Google的工程师总结和抽象成MapReduce框架，大一统了。Parameter Server 就类似于MapReduce，是大规模机器学习在不断使用过程中，抽象出来的框架之一。重点支持的就是参数的分布式，毕竟巨大的模型其实就是巨大的参数。 架构集群中的节点可以分为计算节点和参数服务节点两种。其中，计算节点负责对分配到自己本地的训练数据（块）计算学习，并更新对应的参数；参数服务节点采用分布式存储的方式，各自存储全局参数的一部分，并作为服务方接受计算节点的参数查询和更新请求。计算节点负责干活和更新参数，参数服务节点则负责存储参数。 冗余和恢复：类似MapReduce，每个参数在参数服务器的集群中都在多个不同节点上备份（3个也是极好的），这样当出现节点失效时，冗余的参数依旧能够保证服务的有效性。当有新的节点插入时，把原先失效节点的参数从冗余参数那边复制过来，失效节点的接班人就加入队伍了。 并行计算：并行计算这部分主要在计算节点上进行。 类似于MapReduce，分配任务时，会将数据拆分给每个worker节点。参数服务器在开始学习前，也会把大规模的训练数据拆分到每个计算节点上。单个计算节点就对本地数据进行学习就可以了。学习完毕再把参数的更新梯度上传给对应的参数服务节点进行更新。 优点 Efficient communication：由于是异步的通信，因此，不需要停下来等一些机器执行完一个iteration（除非有必要），这大大减少了延时。为机器学习任务做了一些优化(后续会细讲)，能够大大减少网络流量和开销； Flexible consistency models：宽松的一致性要求进一步减少了同步的成本和延时。parameter server 允许算法设计者根据自身的情况来做算法收敛速度和系统性能之间的trade-off。 Elastic Scalability：使用了一个分布式hash表使得新的server节点可以随时动态的插入到集合中；因此，新增一个节点不需要重新运行系统。 Fault Tolerance and Durability：我们都知道，节点故障是不可避免的，特别是在大规模商用服务器集群中。从非灾难性机器故障中恢复，只需要1秒，而且不需要中断计算。Vector clocks 保证了经历故障之后还是能运行良好； Ease of Use：全局共享的参数可以被表示成各种形式：vector，matrices 或者相应的sparse类型，这大大方便了机器学习算法的开发。并且提供的线性代数的数据类型都具有高性能的多线程库。 6. 高效在线预测平台在线预测平台提供基于超大规模复杂模型的实时预估服务。在线预测服务对响应延迟、稳定性和模型加载时效性等都有极高的要求。对于在线广告、搜索推荐等场景来说，通常要求每个请求的预测时间控制在10~100毫秒之间。除了极低的延迟要求，在线预测服务还需要能够动态加载模型，并能够根据实验流量的自动感知并调整不同模型的负载能力。总体架构图如下图所示： 图12 在线预测平台总体架构 预测框架封装了通信、预测请求的序列化及线程调度等底层细节，并与离线的特征表达、模型描述无缝对接。以便应用算法同学专注于算法开发，避免重复代码引起在线、离线不一致的问题。预测框架和算法分层独立，方便两部分独立迭代演化。下面是MindAlpha的在线预测平台的一些重要特性： 1）基于协程的异步编程API。通过使用Sharded Stackless Coroutine的设计，预测服务能够充分利用多CPU核心进行线性扩展。预测过程需要从实时模型服务、实时特征服务等多个数据源获取数据，支持异步调用使得我们可以并发地发出请求，减少等待。 2）横向、纵向自动扩展的模型服务。模型服务是预测平台的一个组件，它也是一个参数服务器（Parameter Server），将每一份模型拆分成多个分片，使得模型规模不会受到单机内存容量的限制。预测算法根据输入样本从模型服务拉取需要的参数取值。通过拆出独立的模型服务，我们降低了单机的内存消耗，并可通过增加机器数量支持更大的模型规模。由于预测框架具有独立的通信和计算线程，并支持异步调用，拆出独立的模型服务并未导致预测请求的处理效率降低。同时，每一份模型还可以进一步同时提供多个replica，通过增加资源的方式线性增加服务能力。模型预测服务充分利用了云端资源动态扩展的功能，通过对各个模型调用频率负载的动态感知进行实时扩缩容，在保证线上预测高性能、低延迟的同时也有效控制了成本。 3）创新的模型文件格式。模型服务中的参数服务器是只读的，我们设计了高效的模型磁盘数据文件格式，支持矩阵、向量和更复杂的哈希表的编码，并支持用内存映射文件的方式高效地加载模型。使用时，我们先在线下对表和文本格式的模型进行预处理，将其编码为我们自定义的磁盘数据文件格式，在此过程中哈希表中字符串 key 被转为其 uint64 哈希码，数值也从文本格式转为二进制，减小了磁盘空间需求。 4）基于磁盘映射文件的模型加载机制。加载模型时，我们使用磁盘映射文件，模型可瞬间切换，无须一次性执行全部磁盘 IO，也无数据格式转换的过程，使得模型切换延迟极短。模型中实际用到的部分会根据需要由操作系统负责再实时加载需要的内存页，负载是均摊的，且模型中的低频部分可由系统自动换出物理内存。通过这种技术，我们实现了模型线下预处理、线上一键加载切换，减少了模型加载时间，降低了内存和磁盘空间消耗。 6.1 协程的介绍协程提供了一种避免阻塞线程并用更简单、更可控的操作替代线程阻塞的方法：协程挂起。协程主要是让原来要使用“异步+回调方式”写出来的复杂代码, 简化成可以用看似同步的方式写出来（对线程的操作进一步抽象）。这样我们就可以按串行的思维模型去组织原本分散在不同上下文中的代码逻辑，而不需要去处理复杂的状态同步问题。 协程最早的描述是由Melvin Conway于1958年给出：“subroutines who act as the master program”(与主程序行为类似的子例程)。此后他又在博士论文中给出了如下定义： 数据在后续调用中始终保持 当控制流程离开时，协程的执行被挂起，此后控制流程再次进入这个协程时，这个协程只应从上次离开挂起的地方继续 。 协程的实现要维护一组局部状态，在重新进入协程前，保证这些状态不被改变，从而能顺利定位到之前的位置。协程可以用来解决很多问题，比如nodejs的嵌套回调，Erlang以及Golang的并发模型实现等。 协程与线程 Coroutine是编译器级的，Process和Thread是操作系统级的。 Coroutine通常是由编译器来实现的机制。Process和Thread看起来也在语言层次，但是内生原理却是操作系统先有这个东西，然后通过一定的API暴露给用户使用，两者在这里有不同。 协程就是用户空间下的线程。用协程来做的东西，用线程或进程通常也是一样可以做的，但往往多了许多加锁和通信的操作。 线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。 协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程。 线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。 协程的好处与多线程、多进程等并发模型不同，协程依靠user-space调度，而线程、进程则是依靠kernel来进行调度。线程、进程间切换都需要从用户态进入内核态，而协程的切换完全是在用户态完成，且不像线程进行抢占式调度，协程是非抢占式的调度。通常多个运行在同一调度器中的协程运行在一个线程内，这也消除掉了多线程同步等带来的编程复杂性。同一时刻同一调度器中的协程只有一个会处于运行状态。 7. 算法模型组件MindAlpha平台提供了成熟的算法组件，包括经典的FTRL、XNN、RL算法模型等；同时针对搜索、推荐、广告的领域的超大规模离散特征和数据的特点做了针对性优化，做到了开箱即用，直接服务于线上业务。在广告业务领域，MindAlpha能够支持CPM、CPC、CPE、CPI等多种类型的广告业务的个性化排序。以常用FTRL模型为例，MindAlpha平台提供了直接支持特征组合后样本进行训练的功能，对CTR、CVR、IVR等指标进行建模，并与在线预测服务无缝打通，省去特征编码、解码的步骤，直接将特征规模提升到百亿级。 MindAlpha平台在服务于集团发展的过程中，贴合不同业务场景的特点，借助自身的强大数据处理能力、大规模分布式训练框架和高性能在线预测平台，分阶段自研了多个行业领先的算法模型组件，包括ESSM、DF-ESMM、DF-ESMM-DNN、DRL等。平台总的算法模型组件框架如下图示意： 下面对几个特色的算法组件进行展开介绍：1）ESMM即Entire Space Multi-task Model，针对广告业务的CVR预估模型中存在的样本采样偏差和数据稀疏性，对CTR和CVR联合建模训练求解，在原有IVR预估的基础上借鉴Multi-task Learning思想，引入Click Event信息量： 图13 ESMM 算法 2）DF-ESMM Online Learning的求解框架，首先假设在特征空间内，Label分布随时间变化平稳；但在移动展示广告的场景中，经常存在转化数据的滞后性，引起Label在特征空间分布的剧烈波动，严重影响模型效果。应对这个问题，引入转化延迟（DF: Delay Feedback）模型。 图14 DF-ESMM 算法 3）DF-ESMM-DNN 在CTR模型和CVR模型未考虑延迟反馈的部分，分别使用DNN建模，共享Embedding层参数。 图15 DF-ESMM-DNN 算法 4）DRL 除了传统的深度学习和在线学习体系，我们还尝试使用最新的深度强化学习体系对我们的程序化广告投放引擎进行建模。具体来讲，我们将广告投放引擎看作智能体（Agent），把设备用户看作环境（Environment），则广告的投放问题可以被视为典型的顺序决策问题。Agent每一次排序策略的选择可以看成一次试错(Trial-and-Error)，把用户的反馈：点击/安装等作为从环境获得的奖赏。在这种反复不断地试错过程中，Agent将逐步学习到最优的排序策略，最大化累计奖赏。而这种在与环境交互的过程中进行试错的学习，正是强化学习(Reinforcement Learning，RL)的根本思想。通过这种方式，我们的广告投放引擎能逐步进化，实现平台广告收益的累积最大化。类似的方式也可以无缝对接到其他互联网业务如个性化推荐、搜索等的建模优化。 7.1 Entire Space Multitask Model (ESMM)介绍参考链接论文地址 阿里妈妈算法团队发表了一篇题为《Entire Space Multi-Task Model: An Eﬀective Approach for Estimating Post-Click Conversion Rate》的论文，公开了全新的CVR预估模型。该模型解决了传统CVR预估模型难以克服的样本选择偏差和训练数据过于稀疏的问题，同时开放了业界首个包含用户序贯行为的大规模数据集。准确预估转化率在诸如信息检索、推荐系统、在线广告投放系统等工业级的应用中是至关重要的。例如在电商平台的推荐系统中，最大化场景商品交易总额（GMV）是平台的重要目标之一，而GMV可以拆解为流量×点击率×转化率×客单价，可见转化率是优化GMV目标的重要因子，从用户体验的角度来说准确预估的转换率被用来平衡用户的点击偏好与购买偏好。 ESMM模型创新地利用用户行为的序贯特性，在完整的样本数据空间同时学习点击率(post-view click-through rate, CTR)和转化率(post-click conversion rate, CVR)，解决了传统CVR预估模型难以克服的样本选择偏差（sample selection bias）和训练数据过于稀疏（data sparsity）的问题。 ESMM模型是一个新颖的CVR预估方法，其首创了利用用户行为的序贯特性在完整样本空间建模，避免了传统CVR模型经常遭遇的样本选择偏差和训练数据稀疏的问题，取得了显著的效果。同时，ESMM模型中的子网络可以替换为任意的学习模型，因此ESMM的框架可以非常容易地和其他学习模型集成，从而吸收其他学习模型的优势，进一步提升学习效果。此外，ESMM建模的思想也比较容易被泛化到电商中多阶段行为的全链路预估场景，如 排序→展现→点击→转化 的行为链路预估，想象空间巨大。 7.2 DRL 深度增强学习 背景深度增强学习（Deep Reinforcement Learning，DRL）是近两年来深度学习领域迅猛发展起来的一个分支，目的是解决计算机从感知到决策控制的问题，从而实现通用人工智能。以Google DeepMind公司为首，基于深度增强学习的算法已经在视频、游戏、围棋、机器人等领域取得了突破性进展。2016年Google DeepMind推出的AlphaGo围棋系统，使用蒙特卡洛树搜索和深度学习结合的方式使计算机的围棋水平达到甚至超过了顶尖职业棋手的水平，引起了世界性的轰动。AlphaGo的核心就在于使用了深度增强学习算法，使得计算机能够通过自对弈的方式不断提升棋力。深度增强学习算法由于能够基于深度神经网络实现从感知到决策控制的端到端自学习，具有非常广阔的应用前景，它的发展也将进一步推动人工智能的革命。 深度增强学习与通用人工智能当前深度学习已经在计算机视觉、语音识别、自然语言理解等领域取得了突破，相关技术也已经逐渐成熟并落地进入到我们的生活当中。然而，这些领域研究的问题都只是为了让计算机能够感知和理解这个世界。以此同时，决策控制才是人工智能领域要解决的核心问题。计算机视觉等感知问题要求输入感知信息到计算机，计算机能够理解，而决策控制问题则要求计算机能够根据感知信息进行判断思考，输出正确的行为。要使计算机能够很好地决策控制，要求计算机具备一定的“思考”能力，使计算机能够通过学习来掌握解决各种问题的能力，而这正是通用人工智能（Artificial General Intelligence，AGI）（即强人工智能）的研究目标。通用人工智能是要创造出一种无需人工编程自己学会解决各种问题的智能体，最终目标是实现类人级别甚至超人级别的智能。 通用人工智能的基本框架即是增强学习（Reinforcement Learning，RL）的框架，如图 15 所示。 图15 通用人工智能基本框架 智能体的行为都可以归结为与世界的交互。智能体观察这个世界，然后根据观察及自身的状态输出动作，这个世界会因此而发生改变，从而形成回馈返回给智能体。所以核心问题就是如何构建出这样一个能够与世界交互的智能体。深度增强学习将深度学习（Deep Learning）和增强学习（Reinforcement Learning）结合起来，深度学习用来提供学习的机制，而增强学习为深度学习提供学习的目标。这使得深度增强学习具备构建出复杂智能体的潜力，也因此，AlphaGo的第一作者David Silver认为深度增强学习等价于通用人工智能DRL=DL+RL=Universal AI。 深度增强学习的Actor-Critic框架目前深度增强学习的算法都可以包含在Actor-Critic框架下，如图 16 所示。图16 Actor-Critic框架 把深度增强学习的算法认为是智能体的大脑，那么这个大脑包含了两个部分：Actor行动模块和Critic评判模块。其中Actor行动模块是大脑的执行机构，输入外部的状态s，然后输出动作a。而Critic评判模块则可认为是大脑的价值观，根据历史信息及回馈r进行自我调整，然后影响整个Actor行动模块。 这种Actor-Critic的方法非常类似于人类自身的行为方式。我们人类也是在自身价值观和本能的指导下进行行为，并且价值观受经验的影响不断改变。 在Actor-Critic框架下，Google DeepMind相继提出了DQN，A3C和UNREAL等深度增强学习算法，其中UNREAL是目前最好的深度增强学习算法。 三、 总结与展望MindAlpha平台构建了面向大规模互联网核心业务的人工智能一站式服务平台，奠定了企业级AI应用的基础。通过多种云端部署方案快速搭建，开箱即用，高效服务于在线业务。目前基于MindAlpha平台的一站式服务体系，已支持了Mobvista多个在线业务的服务体系，包括：海量中部媒体的程序化投放，头部大媒体的智能化投放，以及传统网盟业务的反作弊算法体系等。 事实上，我们能清晰地看到各个行业各个维度对AI的诉求都是非常之大的。MindAlpha后续也会考虑对外直接提供AI服务，在科技巨头之外，为行业的中小公司提供一种新的AI服务选择。Mobvista集团算法科学家陈绪（前阿里XPS机器学习平台负责人）表示，MindAlpha是为大规模互联网业务而生，全流程一站式的企业级人工智能平台，其技术架构已经达到甚至领先于一线大型互联网公司，代表着业内领先的一流水准。 高速发展中的汇量科技，未来会遇到更多挑战性的业务问题，MindAlpha平台也会在伴随上层业务的发展过程中不断地推进和演化。AI as a Service会是平台持续发展过程中的坚定理念。","link":"/2018/10/24/MindAlpha调研报告/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"项目","slug":"项目","link":"/tags/项目/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"调研","slug":"调研","link":"/tags/调研/"}],"categories":[{"name":"Java8 编程开发入门笔记","slug":"Java8-编程开发入门笔记","link":"/categories/Java8-编程开发入门笔记/"},{"name":"Hexo 入门","slug":"Hexo-入门","link":"/categories/Hexo-入门/"},{"name":"调研报告","slug":"调研报告","link":"/categories/调研报告/"}]}